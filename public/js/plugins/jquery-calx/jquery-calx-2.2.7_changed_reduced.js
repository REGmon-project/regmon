/**
 * jQuery Calx 2.2.7
 *
 * author       : Xsanisty Developer Team <developers@xsanisty.com>
 *                Ikhsan Agustian <ikhsan017@gmail.com>
 * website      : http://www.xsanisty.com/project/calx2
 * repository   : https://github.com/xsanisty/jquery-calx
 * license      : MIT
 */

/**
 * fixed compination of libraries
 * formula.js (http://www.stoic.com/pages/formula)  and
 * jquery-calx.js (https://github.com/xsanisty/jquery-calx) 
 * 
 * Changes by MAD to fit in Regman/Regmon project
 * =================================================================
 * This is a reduced version. I have removed unused Excel functions.
 * =================================================================
 */


if(typeof(Zepto)     == 'undefined'){
    Zepto    = undefined;
}
if(typeof(jQuery)    == 'undefined'){
    jQuery   = Zepto;
}
if(typeof(numeral)   == 'undefined'){
    numeral  = undefined;
}
if(typeof(moment)    == 'undefined'){
    moment   = undefined;
}
if(typeof(jStat)     == 'undefined'){
    jStat    = undefined;
}

(function($, numeral, moment, jStat){

    if(typeof($) == 'undefined'){
        return false;
    }
    
    /************************************************
     *                Begin of IE Hack              *
     ************************************************/
    //ie support for Array.indexOf
    if (typeof Array.indexOf !== "function") {
        Array.prototype.indexOf = function(obj, start) {
            for (var i = (start || 0); i < this.length; i++) {
                if (this[i] == obj) {
                    return i;
                }
            }
            return -1;
        };
    }

    //ie support for getPrototypeOf
    if (typeof Object.getPrototypeOf !== "function") {
        if (typeof "test".__proto__ === "object") {
            Object.getPrototypeOf = function(object) {
                return object.__proto__;
            };
        } else {
            Object.getPrototypeOf = function(object) {
                // May break if the constructor has been tampered with
                return object.constructor.prototype;
            };
        }
    }
	
/************************************************
*             Default Configuration            *
************************************************/

var defaultConfig = {
    /** tell calx to perform auto calculate after change has been made or trigger calculation manually */
    autoCalculate         : true,

    /** event that trigger calculation to be executed */
    autoCalculateTrigger  : 'blur',

    /** callback triggered right before calculation is performed */
    onBeforeCalculate     : null ,

    /** callback triggered right after calculation is performed */
    onAfterCalculate      : null ,

    /** callback triggered right before calculation result is applied */
    onBeforeRender         : null ,

    /** callback triggered right after calculation result is applied */
    onAfterRender          : null ,

    /** default fomatting rule when data-format is not present */
    defaultFormat         : false,

    /** used for server side formula */
    ajaxUrl               : null,

    /** ajax method used for requesting formula result */
    ajaxMethod            : 'get',

    /** Available option is morris, highchart, d3 */
    graphHandler          : 'flot',

    /** check for circular reference on init, default false */
    checkCircularReference: false,

    /** the sheet data contain list of cells with value, formula, and format */
    data                  : {}
};

function parserFactory(sheet) {
    var parser = {
        trace: function trace() {},
        yy: {},
        symbols_: {
            "error": 2,
            "expressions": 3,
            "e": 4,
            "EOF": 5,
            "variableSequence": 6,
            "TRUE": 7,
            "FALSE": 8,
            "NULL": 9,
            "TIME_AMPM": 10,
            "TIME_24": 11,
            "number": 12,
            "STRING": 13,
            "&": 14,
            "=": 15,
            "+": 16,
            "(": 17,
            ")": 18,
            "[": 19,
            "expseq": 20,
            "]": 21,
            "<": 22,
            ">": 23,
            "NOT": 24,
            "-": 25,
            "*": 26,
            "/": 27,
            "^": 28,
            "E": 29,
            "FUNCTION": 30,
            "cell": 31,
            "FIXEDCELL": 32,
            ":": 33,
            "CELL": 34,
            "SHEET": 35,
            "!": 36,
            "RANGE": 37,
            ";": 38,
            ",": 39,
            "VARIABLE": 40,
            "DECIMAL": 41,
            "NUMBER": 42,
            "%": 43,
            "#": 44,
            "$accept": 0,
            "$end": 1
        },
        terminals_: {
            5: "EOF",
            7: "TRUE",
            8: "FALSE",
            9: "NULL",
            10: "TIME_AMPM",
            11: "TIME_24",
            13: "STRING",
            14: "&",
            15: "=",
            16: "+",
            17: "(",
            18: ")",
            19: "[",
            21: "]",
            22: "<",
            23: ">",
            24: "NOT",
            25: "-",
            26: "*",
            27: "/",
            28: "^",
            29: "E",
            30: "FUNCTION",
            32: "FIXEDCELL",
            33: ":",
            34: "CELL",
            35: "SHEET",
            36: "!",
            37: "RANGE",
            38: ";",
            39: ",",
            40: "VARIABLE",
            41: "DECIMAL",
            42: "NUMBER",
            43: "%",
            44: "#"
        },
        productions_: [0, [3, 2],
            [4, 1],
            [4, 1],
            [4, 1],
            [4, 1],
            [4, 1],
            [4, 1],
            [4, 1],
            [4, 1],
            [4, 3],
            [4, 3],
            [4, 3],
            [4, 3],
            [4, 3],
            [4, 4],
            [4, 4],
            [4, 4],
            [4, 3],
            [4, 3],
            [4, 3],
            [4, 3],
            [4, 3],
            [4, 3],
            [4, 3],
            [4, 2],
            [4, 2],
            [4, 1],
            [4, 3],
            [4, 4],
            [4, 1],
            [4, 1],
            [4, 2],
            [31, 1],
            [31, 3],
            [31, 1],
            [31, 3],
            [31, 3],
            [31, 5],
            [31, 1],
            [31, 3],
            [20, 1],
            [20, 3],
            [20, 3],
            [6, 1],
            [6, 3],
            [12, 1],
            [12, 3],
            [12, 2],
            [2, 3],
            [2, 4]
        ],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            /* this == yyval */

            var $0 = $$.length - 1;
            switch (yystate) {
                case 1:
                    return $$[$0 - 1];
                    break;
                case 2:
                    this.$ = sheet.getVariable($$[$0])

                    break;
                case 3:
                    this.$ = true;

                    break;
                case 4:
                    this.$ = false;

                    break;
                case 5:
                    this.$ = null;

                    break;
                case 6:
                    this.$ = sheet.time($$[$0]);

                    break;
                case 7:
                    this.$ = sheet.time($$[$0]);

                    break;
                case 8:
                    this.$ = $$[$0] * 1;

                    if (isNaN(this.$)) this.$ = 0;

                    break;
                case 9:
                    this.$ = $$[$0].substring(1, $$[$0].length - 1);

                    break;
                case 10:
                    this.$ = '' + $$[$0 - 2] + $$[$0];

                    break;
                case 11:
                    this.$ = sheet.comparator.equal.call(sheet, $$[$0 - 2], $$[$0]);

                    break;
                case 12:
                    this.$ = formula.math.SUM.call(sheet, $$[$0 - 2], $$[$0]);

                    break;
                case 13:
                    this.$ = $$[$0 - 1] * 1;
                    break;
                case 14:
                    this.$ = $$[$0 - 1];

                    break;
                case 15:
                    this.$ = sheet.comparator.lessEqual.call(sheet, $$[$0 - 3], $$[$0]);

                    break;
                case 16:
                    this.$ = sheet.comparator.greaterEqual.call(sheet, $$[$0 - 3], $$[$0]);

                    break;
                case 17:
                    this.$ = sheet.comparator.notEqual.call(sheet, $$[$0 - 3], $$[$0]);

                    break;
                case 18:
                    this.$ = $$[$0 - 2] != $$[$0];

                    break;
                case 19:
                    this.$ = sheet.comparator.greater.call(sheet, $$[$0 - 2], $$[$0]);

                    break;
                case 20:
                    this.$ = sheet.comparator.less.call(sheet, $$[$0 - 2], $$[$0]);

                    break;
                case 21:
                    this.$ = formula.math.SUBTRACT.call(sheet, $$[$0 - 2], $$[$0]);

                    break;
                case 22:
                    this.$ = formula.math.MULTIPLY.call(sheet, $$[$0 - 2], $$[$0]);

                    break;
                case 23:
                    this.$ = formula.math.DIVIDE.call(sheet, $$[$0 - 2], $$[$0]);

                    break;
                case 24:
                    this.$ = formula.math.POWER.call(sheet, $$[$0 - 2], $$[$0]);

                    break;
                case 25:
                    this.$ = $$[$0] * -1;
                    if (isNaN(this.$)) this.$ = 0;

                    break;
                case 26:
                    this.$ = $$[$0] * 1;
                    if (isNaN(this.$)) this.$ = 0;

                    break;
                case 27:
                    this.$ = Math.E;

                    break;
                case 28:
                    this.$ = sheet.callFunction($$[$0 - 2]);

                    break;
                case 29:
                    this.$ = sheet.callFunction($$[$0 - 3], $$[$0 - 1]);

                    break;
                case 33:
                    this.$ = sheet.getCellValue($$[$0]);

                    break;
                case 34:
                    this.$ = sheet.getCellRangeValue($$[$0 - 2], $$[$0]);

                    break;
                case 35:
                    this.$ = sheet.getCellValue($$[$0]);

                    break;
                case 36:
                    this.$ = sheet.getCellRangeValue($$[$0 - 2], $$[$0]);

                    break;
                case 37:
                    this.$ = sheet.getRemoteCellValue($$[$0 - 2], $$[$0]);

                    break;
                case 38:
                    this.$ = sheet.getRemoteCellRangeValue($$[$0 - 4], $$[$0 - 2], $$[$0]);

                    break;
                case 39:
                    this.$ = sheet.getColumnRange($$[$0])

                    break;
                case 40:
                    this.$ = sheet.getRemoteColumnRange($$[$0 - 2], $$[$0]);

                    break;
                case 41:
                    this.$ = [$$[$0]];

                    break;
                case 42:
                    $$[$0 - 2].push($$[$0]);
                    this.$ = $$[$0 - 2];


                    break;
                case 43:
                    $$[$0 - 2].push($$[$0]);
                    this.$ = $$[$0 - 2];


                    break;
                case 44:
                    this.$ = [$$[$0]];

                    break;
                case 45:
                    this.$ = ($.isArray($$[$0 - 2]) ? $$[$0 - 2] : [$$[$0 - 2]]);
                    this.$.push($$[$0]);


                    break;
                case 46:
                    this.$ = $$[$0] * 1;

                    break;
                case 47:
                    this.$ = ($$[$0 - 2] + '.' + $$[$0]) * 1;

                    break;
                case 48:
                    this.$ = $$[$0 - 1] * 0.01;

                    break;
                case 49:
                    this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0];

                    break;
                case 50:
                    this.$ = $$[$0 - 2] + $$[$0 - 1] + $$[$0];

                    break;
            }
        },
        table: [{
            2: 18,
            3: 1,
            4: 2,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            1: [3]
        }, {
            5: [1, 26],
            14: [1, 27],
            15: [1, 28],
            16: [1, 29],
            22: [1, 30],
            23: [1, 31],
            24: [1, 32],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36]
        }, {
            5: [2, 2],
            14: [2, 2],
            15: [2, 2],
            16: [2, 2],
            18: [2, 2],
            21: [2, 2],
            22: [2, 2],
            23: [2, 2],
            24: [2, 2],
            25: [2, 2],
            26: [2, 2],
            27: [2, 2],
            28: [2, 2],
            38: [2, 2],
            39: [2, 2],
            41: [1, 37]
        }, {
            5: [2, 3],
            14: [2, 3],
            15: [2, 3],
            16: [2, 3],
            18: [2, 3],
            21: [2, 3],
            22: [2, 3],
            23: [2, 3],
            24: [2, 3],
            25: [2, 3],
            26: [2, 3],
            27: [2, 3],
            28: [2, 3],
            38: [2, 3],
            39: [2, 3]
        }, {
            5: [2, 4],
            14: [2, 4],
            15: [2, 4],
            16: [2, 4],
            18: [2, 4],
            21: [2, 4],
            22: [2, 4],
            23: [2, 4],
            24: [2, 4],
            25: [2, 4],
            26: [2, 4],
            27: [2, 4],
            28: [2, 4],
            38: [2, 4],
            39: [2, 4]
        }, {
            5: [2, 5],
            14: [2, 5],
            15: [2, 5],
            16: [2, 5],
            18: [2, 5],
            21: [2, 5],
            22: [2, 5],
            23: [2, 5],
            24: [2, 5],
            25: [2, 5],
            26: [2, 5],
            27: [2, 5],
            28: [2, 5],
            38: [2, 5],
            39: [2, 5]
        }, {
            5: [2, 6],
            14: [2, 6],
            15: [2, 6],
            16: [2, 6],
            18: [2, 6],
            21: [2, 6],
            22: [2, 6],
            23: [2, 6],
            24: [2, 6],
            25: [2, 6],
            26: [2, 6],
            27: [2, 6],
            28: [2, 6],
            38: [2, 6],
            39: [2, 6]
        }, {
            5: [2, 7],
            14: [2, 7],
            15: [2, 7],
            16: [2, 7],
            18: [2, 7],
            21: [2, 7],
            22: [2, 7],
            23: [2, 7],
            24: [2, 7],
            25: [2, 7],
            26: [2, 7],
            27: [2, 7],
            28: [2, 7],
            38: [2, 7],
            39: [2, 7]
        }, {
            5: [2, 8],
            14: [2, 8],
            15: [2, 8],
            16: [2, 8],
            18: [2, 8],
            21: [2, 8],
            22: [2, 8],
            23: [2, 8],
            24: [2, 8],
            25: [2, 8],
            26: [2, 8],
            27: [2, 8],
            28: [2, 8],
            38: [2, 8],
            39: [2, 8],
            43: [1, 38]
        }, {
            5: [2, 9],
            14: [2, 9],
            15: [2, 9],
            16: [2, 9],
            18: [2, 9],
            21: [2, 9],
            22: [2, 9],
            23: [2, 9],
            24: [2, 9],
            25: [2, 9],
            26: [2, 9],
            27: [2, 9],
            28: [2, 9],
            38: [2, 9],
            39: [2, 9]
        }, {
            2: 18,
            4: 39,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 41,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            20: 40,
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 42,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 43,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            5: [2, 27],
            14: [2, 27],
            15: [2, 27],
            16: [2, 27],
            18: [2, 27],
            21: [2, 27],
            22: [2, 27],
            23: [2, 27],
            24: [2, 27],
            25: [2, 27],
            26: [2, 27],
            27: [2, 27],
            28: [2, 27],
            38: [2, 27],
            39: [2, 27]
        }, {
            17: [1, 44]
        }, {
            5: [2, 30],
            14: [2, 30],
            15: [2, 30],
            16: [2, 30],
            18: [2, 30],
            21: [2, 30],
            22: [2, 30],
            23: [2, 30],
            24: [2, 30],
            25: [2, 30],
            26: [2, 30],
            27: [2, 30],
            28: [2, 30],
            38: [2, 30],
            39: [2, 30]
        }, {
            2: 45,
            5: [2, 31],
            14: [2, 31],
            15: [2, 31],
            16: [2, 31],
            18: [2, 31],
            21: [2, 31],
            22: [2, 31],
            23: [2, 31],
            24: [2, 31],
            25: [2, 31],
            26: [2, 31],
            27: [2, 31],
            28: [2, 31],
            38: [2, 31],
            39: [2, 31],
            40: [1, 46],
            44: [1, 25]
        }, {
            5: [2, 44],
            14: [2, 44],
            15: [2, 44],
            16: [2, 44],
            18: [2, 44],
            21: [2, 44],
            22: [2, 44],
            23: [2, 44],
            24: [2, 44],
            25: [2, 44],
            26: [2, 44],
            27: [2, 44],
            28: [2, 44],
            38: [2, 44],
            39: [2, 44],
            41: [2, 44],
            44: [1, 47]
        }, {
            5: [2, 46],
            14: [2, 46],
            15: [2, 46],
            16: [2, 46],
            18: [2, 46],
            21: [2, 46],
            22: [2, 46],
            23: [2, 46],
            24: [2, 46],
            25: [2, 46],
            26: [2, 46],
            27: [2, 46],
            28: [2, 46],
            38: [2, 46],
            39: [2, 46],
            41: [1, 48],
            43: [2, 46]
        }, {
            5: [2, 33],
            14: [2, 33],
            15: [2, 33],
            16: [2, 33],
            18: [2, 33],
            21: [2, 33],
            22: [2, 33],
            23: [2, 33],
            24: [2, 33],
            25: [2, 33],
            26: [2, 33],
            27: [2, 33],
            28: [2, 33],
            33: [1, 49],
            38: [2, 33],
            39: [2, 33]
        }, {
            5: [2, 35],
            14: [2, 35],
            15: [2, 35],
            16: [2, 35],
            18: [2, 35],
            21: [2, 35],
            22: [2, 35],
            23: [2, 35],
            24: [2, 35],
            25: [2, 35],
            26: [2, 35],
            27: [2, 35],
            28: [2, 35],
            33: [1, 50],
            38: [2, 35],
            39: [2, 35]
        }, {
            36: [1, 51]
        }, {
            5: [2, 39],
            14: [2, 39],
            15: [2, 39],
            16: [2, 39],
            18: [2, 39],
            21: [2, 39],
            22: [2, 39],
            23: [2, 39],
            24: [2, 39],
            25: [2, 39],
            26: [2, 39],
            27: [2, 39],
            28: [2, 39],
            38: [2, 39],
            39: [2, 39]
        }, {
            40: [1, 52]
        }, {
            1: [2, 1]
        }, {
            2: 18,
            4: 53,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 54,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 55,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 58,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            15: [1, 56],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            23: [1, 57],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 60,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            15: [1, 59],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 61,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 62,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 63,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 64,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 65,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            40: [1, 66]
        }, {
            5: [2, 48],
            14: [2, 48],
            15: [2, 48],
            16: [2, 48],
            18: [2, 48],
            21: [2, 48],
            22: [2, 48],
            23: [2, 48],
            24: [2, 48],
            25: [2, 48],
            26: [2, 48],
            27: [2, 48],
            28: [2, 48],
            38: [2, 48],
            39: [2, 48],
            43: [2, 48]
        }, {
            14: [1, 27],
            15: [1, 28],
            16: [1, 29],
            18: [1, 67],
            22: [1, 30],
            23: [1, 31],
            24: [1, 32],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36]
        }, {
            21: [1, 68],
            38: [1, 69],
            39: [1, 70]
        }, {
            14: [1, 27],
            15: [1, 28],
            16: [1, 29],
            18: [2, 41],
            21: [2, 41],
            22: [1, 30],
            23: [1, 31],
            24: [1, 32],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 41],
            39: [2, 41]
        }, {
            5: [2, 25],
            14: [2, 25],
            15: [2, 25],
            16: [2, 25],
            18: [2, 25],
            21: [2, 25],
            22: [2, 25],
            23: [2, 25],
            24: [2, 25],
            25: [2, 25],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 25],
            39: [2, 25]
        }, {
            5: [2, 26],
            14: [2, 26],
            15: [2, 26],
            16: [2, 26],
            18: [2, 26],
            21: [2, 26],
            22: [2, 26],
            23: [2, 26],
            24: [2, 26],
            25: [2, 26],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 26],
            39: [2, 26]
        }, {
            2: 18,
            4: 41,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            18: [1, 71],
            19: [1, 12],
            20: 72,
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            5: [2, 32],
            14: [2, 32],
            15: [2, 32],
            16: [2, 32],
            18: [2, 32],
            21: [2, 32],
            22: [2, 32],
            23: [2, 32],
            24: [2, 32],
            25: [2, 32],
            26: [2, 32],
            27: [2, 32],
            28: [2, 32],
            38: [2, 32],
            39: [2, 32]
        }, {
            44: [1, 47]
        }, {
            40: [1, 73]
        }, {
            42: [1, 74]
        }, {
            32: [1, 75]
        }, {
            34: [1, 76]
        }, {
            34: [1, 77],
            37: [1, 78]
        }, {
            36: [1, 79]
        }, {
            5: [2, 10],
            14: [2, 10],
            15: [2, 10],
            16: [1, 29],
            18: [2, 10],
            21: [2, 10],
            22: [1, 30],
            23: [1, 31],
            24: [1, 32],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 10],
            39: [2, 10]
        }, {
            5: [2, 11],
            14: [2, 11],
            15: [2, 11],
            16: [1, 29],
            18: [2, 11],
            21: [2, 11],
            22: [1, 30],
            23: [1, 31],
            24: [1, 32],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 11],
            39: [2, 11]
        }, {
            5: [2, 12],
            14: [2, 12],
            15: [2, 12],
            16: [2, 12],
            18: [2, 12],
            21: [2, 12],
            22: [2, 12],
            23: [2, 12],
            24: [2, 12],
            25: [2, 12],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 12],
            39: [2, 12]
        }, {
            2: 18,
            4: 80,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 81,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            5: [2, 20],
            14: [2, 20],
            15: [2, 20],
            16: [1, 29],
            18: [2, 20],
            21: [2, 20],
            22: [2, 20],
            23: [2, 20],
            24: [2, 20],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 20],
            39: [2, 20]
        }, {
            2: 18,
            4: 82,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            5: [2, 19],
            14: [2, 19],
            15: [2, 19],
            16: [1, 29],
            18: [2, 19],
            21: [2, 19],
            22: [2, 19],
            23: [2, 19],
            24: [2, 19],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 19],
            39: [2, 19]
        }, {
            5: [2, 18],
            14: [2, 18],
            15: [2, 18],
            16: [1, 29],
            18: [2, 18],
            21: [2, 18],
            22: [1, 30],
            23: [1, 31],
            24: [2, 18],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 18],
            39: [2, 18]
        }, {
            5: [2, 21],
            14: [2, 21],
            15: [2, 21],
            16: [2, 21],
            18: [2, 21],
            21: [2, 21],
            22: [2, 21],
            23: [2, 21],
            24: [2, 21],
            25: [2, 21],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 21],
            39: [2, 21]
        }, {
            5: [2, 22],
            14: [2, 22],
            15: [2, 22],
            16: [2, 22],
            18: [2, 22],
            21: [2, 22],
            22: [2, 22],
            23: [2, 22],
            24: [2, 22],
            25: [2, 22],
            26: [2, 22],
            27: [2, 22],
            28: [1, 36],
            38: [2, 22],
            39: [2, 22]
        }, {
            5: [2, 23],
            14: [2, 23],
            15: [2, 23],
            16: [2, 23],
            18: [2, 23],
            21: [2, 23],
            22: [2, 23],
            23: [2, 23],
            24: [2, 23],
            25: [2, 23],
            26: [2, 23],
            27: [2, 23],
            28: [1, 36],
            38: [2, 23],
            39: [2, 23]
        }, {
            5: [2, 24],
            14: [2, 24],
            15: [2, 24],
            16: [2, 24],
            18: [2, 24],
            21: [2, 24],
            22: [2, 24],
            23: [2, 24],
            24: [2, 24],
            25: [2, 24],
            26: [2, 24],
            27: [2, 24],
            28: [2, 24],
            38: [2, 24],
            39: [2, 24]
        }, {
            5: [2, 45],
            14: [2, 45],
            15: [2, 45],
            16: [2, 45],
            18: [2, 45],
            21: [2, 45],
            22: [2, 45],
            23: [2, 45],
            24: [2, 45],
            25: [2, 45],
            26: [2, 45],
            27: [2, 45],
            28: [2, 45],
            38: [2, 45],
            39: [2, 45],
            41: [2, 45]
        }, {
            5: [2, 13],
            14: [2, 13],
            15: [2, 13],
            16: [2, 13],
            18: [2, 13],
            21: [2, 13],
            22: [2, 13],
            23: [2, 13],
            24: [2, 13],
            25: [2, 13],
            26: [2, 13],
            27: [2, 13],
            28: [2, 13],
            38: [2, 13],
            39: [2, 13]
        }, {
            5: [2, 14],
            14: [2, 14],
            15: [2, 14],
            16: [2, 14],
            18: [2, 14],
            21: [2, 14],
            22: [2, 14],
            23: [2, 14],
            24: [2, 14],
            25: [2, 14],
            26: [2, 14],
            27: [2, 14],
            28: [2, 14],
            38: [2, 14],
            39: [2, 14]
        }, {
            2: 18,
            4: 83,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            2: 18,
            4: 84,
            6: 3,
            7: [1, 4],
            8: [1, 5],
            9: [1, 6],
            10: [1, 7],
            11: [1, 8],
            12: 9,
            13: [1, 10],
            16: [1, 14],
            17: [1, 11],
            19: [1, 12],
            25: [1, 13],
            29: [1, 15],
            30: [1, 16],
            31: 17,
            32: [1, 21],
            34: [1, 22],
            35: [1, 23],
            37: [1, 24],
            40: [1, 19],
            42: [1, 20],
            44: [1, 25]
        }, {
            5: [2, 28],
            14: [2, 28],
            15: [2, 28],
            16: [2, 28],
            18: [2, 28],
            21: [2, 28],
            22: [2, 28],
            23: [2, 28],
            24: [2, 28],
            25: [2, 28],
            26: [2, 28],
            27: [2, 28],
            28: [2, 28],
            38: [2, 28],
            39: [2, 28]
        }, {
            18: [1, 85],
            38: [1, 69],
            39: [1, 70]
        }, {
            36: [1, 86]
        }, {
            5: [2, 47],
            14: [2, 47],
            15: [2, 47],
            16: [2, 47],
            18: [2, 47],
            21: [2, 47],
            22: [2, 47],
            23: [2, 47],
            24: [2, 47],
            25: [2, 47],
            26: [2, 47],
            27: [2, 47],
            28: [2, 47],
            38: [2, 47],
            39: [2, 47],
            43: [2, 47]
        }, {
            5: [2, 34],
            14: [2, 34],
            15: [2, 34],
            16: [2, 34],
            18: [2, 34],
            21: [2, 34],
            22: [2, 34],
            23: [2, 34],
            24: [2, 34],
            25: [2, 34],
            26: [2, 34],
            27: [2, 34],
            28: [2, 34],
            38: [2, 34],
            39: [2, 34]
        }, {
            5: [2, 36],
            14: [2, 36],
            15: [2, 36],
            16: [2, 36],
            18: [2, 36],
            21: [2, 36],
            22: [2, 36],
            23: [2, 36],
            24: [2, 36],
            25: [2, 36],
            26: [2, 36],
            27: [2, 36],
            28: [2, 36],
            38: [2, 36],
            39: [2, 36]
        }, {
            5: [2, 37],
            14: [2, 37],
            15: [2, 37],
            16: [2, 37],
            18: [2, 37],
            21: [2, 37],
            22: [2, 37],
            23: [2, 37],
            24: [2, 37],
            25: [2, 37],
            26: [2, 37],
            27: [2, 37],
            28: [2, 37],
            33: [1, 87],
            38: [2, 37],
            39: [2, 37]
        }, {
            5: [2, 40],
            14: [2, 40],
            15: [2, 40],
            16: [2, 40],
            18: [2, 40],
            21: [2, 40],
            22: [2, 40],
            23: [2, 40],
            24: [2, 40],
            25: [2, 40],
            26: [2, 40],
            27: [2, 40],
            28: [2, 40],
            38: [2, 40],
            39: [2, 40]
        }, {
            5: [2, 49],
            14: [2, 49],
            15: [2, 49],
            16: [2, 49],
            18: [2, 49],
            21: [2, 49],
            22: [2, 49],
            23: [2, 49],
            24: [2, 49],
            25: [2, 49],
            26: [2, 49],
            27: [2, 49],
            28: [2, 49],
            38: [2, 49],
            39: [2, 49],
            40: [2, 49],
            44: [2, 49]
        }, {
            5: [2, 15],
            14: [2, 15],
            15: [2, 15],
            16: [1, 29],
            18: [2, 15],
            21: [2, 15],
            22: [2, 15],
            23: [2, 15],
            24: [2, 15],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 15],
            39: [2, 15]
        }, {
            5: [2, 17],
            14: [2, 17],
            15: [2, 17],
            16: [1, 29],
            18: [2, 17],
            21: [2, 17],
            22: [2, 17],
            23: [2, 17],
            24: [2, 17],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 17],
            39: [2, 17]
        }, {
            5: [2, 16],
            14: [2, 16],
            15: [2, 16],
            16: [1, 29],
            18: [2, 16],
            21: [2, 16],
            22: [2, 16],
            23: [2, 16],
            24: [2, 16],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 16],
            39: [2, 16]
        }, {
            14: [1, 27],
            15: [1, 28],
            16: [1, 29],
            18: [2, 42],
            21: [2, 42],
            22: [1, 30],
            23: [1, 31],
            24: [1, 32],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 42],
            39: [2, 42]
        }, {
            14: [1, 27],
            15: [1, 28],
            16: [1, 29],
            18: [2, 43],
            21: [2, 43],
            22: [1, 30],
            23: [1, 31],
            24: [1, 32],
            25: [1, 33],
            26: [1, 34],
            27: [1, 35],
            28: [1, 36],
            38: [2, 43],
            39: [2, 43]
        }, {
            5: [2, 29],
            14: [2, 29],
            15: [2, 29],
            16: [2, 29],
            18: [2, 29],
            21: [2, 29],
            22: [2, 29],
            23: [2, 29],
            24: [2, 29],
            25: [2, 29],
            26: [2, 29],
            27: [2, 29],
            28: [2, 29],
            38: [2, 29],
            39: [2, 29]
        }, {
            5: [2, 50],
            14: [2, 50],
            15: [2, 50],
            16: [2, 50],
            18: [2, 50],
            21: [2, 50],
            22: [2, 50],
            23: [2, 50],
            24: [2, 50],
            25: [2, 50],
            26: [2, 50],
            27: [2, 50],
            28: [2, 50],
            38: [2, 50],
            39: [2, 50],
            40: [2, 50],
            44: [2, 50]
        }, {
            34: [1, 88]
        }, {
            5: [2, 38],
            14: [2, 38],
            15: [2, 38],
            16: [2, 38],
            18: [2, 38],
            21: [2, 38],
            22: [2, 38],
            23: [2, 38],
            24: [2, 38],
            25: [2, 38],
            26: [2, 38],
            27: [2, 38],
            28: [2, 38],
            38: [2, 38],
            39: [2, 38]
        }],
        defaultActions: {
            26: [2, 1]
        },
        parseError: function parseError(str, hash) {
            if (hash.recoverable) {
                this.trace(str)
            } else {
                throw new Error(str)
            }
        },
        parse: function parse(input) {
            var self = this,
                stack = [0],
                vstack = [null],
                lstack = [],
                table = this.table,
                yytext = "",
                yylineno = 0,
                yyleng = 0,
                recovering = 0,
                TERROR = 2,
                EOF = 1;
            var args = lstack.slice.call(arguments, 1);
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined") {
                this.lexer.yylloc = {}
            }
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function") {
                this.parseError = this.yy.parseError
            } else {
                this.parseError = Object.getPrototypeOf(this).parseError
            }

            function popStack(n) {
                stack.length = stack.length - 2 * n;
                vstack.length = vstack.length - n;
                lstack.length = lstack.length - n
            }

            function lex() {
                var token;
                token = self.lexer.lex() || EOF;
                if (typeof token !== "number") {
                    token = self.symbols_[token] || token
                }
                return token
            }
            var symbol, preErrorSymbol, state, action, a, r, yyval = {},
                p, len, newState, expected;
            while (true) {
                state = stack[stack.length - 1];
                if (this.defaultActions[state]) {
                    action = this.defaultActions[state]
                } else {
                    if (symbol === null || typeof symbol == "undefined") {
                        symbol = lex()
                    }
                    action = table[state] && table[state][symbol]
                }
                _handle_error: if (typeof action === "undefined" || !action.length || !action[0]) {
                    var error_rule_depth;
                    var errStr = "";

                    function locateNearestErrorRecoveryRule(state) {
                        var stack_probe = stack.length - 1;
                        var depth = 0;
                        for (;;) {
                            if (TERROR.toString() in table[state]) {
                                return depth
                            }
                            if (state === 0 || stack_probe < 2) {
                                return false
                            }
                            stack_probe -= 2;
                            state = stack[stack_probe];
                            ++depth
                        }
                    }
                    if (!recovering) {
                        error_rule_depth = locateNearestErrorRecoveryRule(state);
                        expected = [];
                        for (p in table[state]) {
                            if (this.terminals_[p] && p > TERROR) {
                                expected.push("'" + this.terminals_[p] + "'")
                            }
                        }
                        if (this.lexer.showPosition) {
                            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'"
                        } else {
                            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == EOF ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'")
                        }
                        this.parseError(errStr, {
                            text: this.lexer.match,
                            token: this.terminals_[symbol] || symbol,
                            line: this.lexer.yylineno,
                            loc: yyloc,
                            expected: expected,
                            recoverable: error_rule_depth !== false
                        })
                    } else if (preErrorSymbol !== EOF) {
                        error_rule_depth = locateNearestErrorRecoveryRule(state)
                    }
                    if (recovering == 3) {
                        if (symbol === EOF || preErrorSymbol === EOF) {
                            throw new Error(errStr || "Parsing halted while starting to recover from another error.")
                        }
                        yyleng = this.lexer.yyleng;
                        yytext = this.lexer.yytext;
                        yylineno = this.lexer.yylineno;
                        yyloc = this.lexer.yylloc;
                        symbol = lex()
                    }
                    if (error_rule_depth === false) {
                        throw new Error(errStr || "Parsing halted. No suitable error recovery rule available.")
                    }
                    popStack(error_rule_depth);
                    preErrorSymbol = symbol == TERROR ? null : symbol;
                    symbol = TERROR;
                    state = stack[stack.length - 1];
                    action = table[state] && table[state][TERROR];
                    recovering = 3
                }
                if (action[0] instanceof Array && action.length > 1) {
                    throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol)
                }
                switch (action[0]) {
                    case 1:
                        stack.push(symbol);
                        vstack.push(this.lexer.yytext);
                        lstack.push(this.lexer.yylloc);
                        stack.push(action[1]);
                        symbol = null;
                        if (!preErrorSymbol) {
                            yyleng = this.lexer.yyleng;
                            yytext = this.lexer.yytext;
                            yylineno = this.lexer.yylineno;
                            yyloc = this.lexer.yylloc;
                            if (recovering > 0) {
                                recovering--
                            }
                        } else {
                            symbol = preErrorSymbol;
                            preErrorSymbol = null
                        }
                        break;
                    case 2:
                        len = this.productions_[action[1]][1];
                        yyval.$ = vstack[vstack.length - len];
                        yyval._$ = {
                            first_line: lstack[lstack.length - (len || 1)].first_line,
                            last_line: lstack[lstack.length - 1].last_line,
                            first_column: lstack[lstack.length - (len || 1)].first_column,
                            last_column: lstack[lstack.length - 1].last_column
                        };
                        if (ranges) {
                            yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]]
                        }
                        r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack].concat(args));
                        if (typeof r !== "undefined") {
                            return r
                        }
                        if (len) {
                            stack = stack.slice(0, -1 * len * 2);
                            vstack = vstack.slice(0, -1 * len);
                            lstack = lstack.slice(0, -1 * len)
                        }
                        stack.push(this.productions_[action[1]][0]);
                        vstack.push(yyval.$);
                        lstack.push(yyval._$);
                        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                        stack.push(newState);
                        break;
                    case 3:
                        return true
                }
            }
            return true
        }
    };
	
    /* generated by jison-lex 0.2.1 */
    var lexer = (function() {
        var lexer = {

            EOF: 1,

            parseError: function parseError(str, hash) {
                "use strict";
                if (this.yy.parser) {
                    this.yy.parser.parseError(str, hash)
                } else {
                    throw new Error(str)
                }
            },

            // resets the lexer, sets new input
            setInput: function(input) {
                "use strict";
                this._input = input;
                this._more = this._backtrack = this.done = false;
                this.yylineno = this.yyleng = 0;
                this.yytext = this.matched = this.match = "";
                this.conditionStack = ["INITIAL"];
                this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0
                };
                if (this.options.ranges) {
                    this.yylloc.range = [0, 0]
                }
                this.offset = 0;
                return this
            },

            // consumes and returns one char from the input
            input: function() {
                "use strict";
                var ch = this._input[0];
                this.yytext += ch;
                this.yyleng++;
                this.offset++;
                this.match += ch;
                this.matched += ch;
                var lines = ch.match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno++;
                    this.yylloc.last_line++
                } else {
                    this.yylloc.last_column++
                }
                if (this.options.ranges) {
                    this.yylloc.range[1]++
                }
                this._input = this._input.slice(1);
                return ch
            },

            // unshifts one char (or a string) into the input
            unput: function(ch) {
                "use strict";
                var len = ch.length;
                var lines = ch.split(/(?:\r\n?|\n)/g);
                this._input = ch + this._input;
                this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
                this.offset -= len;
                var oldLines = this.match.split(/(?:\r\n?|\n)/g);
                this.match = this.match.substr(0, this.match.length - 1);
                this.matched = this.matched.substr(0, this.matched.length - 1);
                if (lines.length - 1) {
                    this.yylineno -= lines.length - 1
                }
                var r = this.yylloc.range;
                this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
                };
                if (this.options.ranges) {
                    this.yylloc.range = [r[0], r[0] + this.yyleng - len]
                }
                this.yyleng = this.yytext.length;
                return this
            },

            // When called from action, caches matched text and appends it on next action
            more: function() {
                "use strict";
                this._more = true;
                return this
            },

            // When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
            reject: function() {
                "use strict";
                if (this.options.backtrack_lexer) {
                    this._backtrack = true
                } else {
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    })
                }
                return this
            },

            // retain first n characters of the match
            less: function(n) {
                "use strict";
                this.unput(this.match.slice(n))
            },

            // displays already matched input, i.e. for error messages
            pastInput: function() {
                "use strict";
                var past = this.matched.substr(0, this.matched.length - this.match.length);
                return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "")
            },

            // displays upcoming input, i.e. for error messages
            upcomingInput: function() {
                "use strict";
                var next = this.match;
                if (next.length < 20) {
                    next += this._input.substr(0, 20 - next.length)
                }
                return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "")
            },

            // displays the character position where the lexing error occurred, i.e. for error messages
            showPosition: function() {
                "use strict";
                var pre = this.pastInput();
                var c = new Array(pre.length + 1).join("-");
                return pre + this.upcomingInput() + "\n" + c + "^"
            },

            // test the lexed token: return FALSE when not a match, otherwise return token
            test_match: function(match, indexed_rule) {
                "use strict";
                var token, lines, backup;
                if (this.options.backtrack_lexer) {
                    backup = {
                        yylineno: this.yylineno,
                        yylloc: {
                            first_line: this.yylloc.first_line,
                            last_line: this.last_line,
                            first_column: this.yylloc.first_column,
                            last_column: this.yylloc.last_column
                        },
                        yytext: this.yytext,
                        match: this.match,
                        matches: this.matches,
                        matched: this.matched,
                        yyleng: this.yyleng,
                        offset: this.offset,
                        _more: this._more,
                        _input: this._input,
                        yy: this.yy,
                        conditionStack: this.conditionStack.slice(0),
                        done: this.done
                    };
                    if (this.options.ranges) {
                        backup.yylloc.range = this.yylloc.range.slice(0)
                    }
                }
                lines = match[0].match(/(?:\r\n?|\n).*/g);
                if (lines) {
                    this.yylineno += lines.length
                }
                this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
                };
                this.yytext += match[0];
                this.match += match[0];
                this.matches = match;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                    this.yylloc.range = [this.offset, this.offset += this.yyleng]
                }
                this._more = false;
                this._backtrack = false;
                this._input = this._input.slice(match[0].length);
                this.matched += match[0];
                token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input) {
                    this.done = false
                }
                if (token) {
                    return token
                } else if (this._backtrack) {
                    for (var k in backup) {
                        this[k] = backup[k]
                    }
                    return false
                }
                return false
            },

            // return next match in input
            next: function() {
                "use strict";
                if (this.done) {
                    return this.EOF
                }
                if (!this._input) {
                    this.done = true
                }
                var token, match, tempMatch, index;
                if (!this._more) {
                    this.yytext = "";
                    this.match = ""
                }
                var rules = this._currentRules();
                for (var i = 0; i < rules.length; i++) {
                    tempMatch = this._input.match(this.rules[rules[i]]);
                    if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                        match = tempMatch;
                        index = i;
                        if (this.options.backtrack_lexer) {
                            token = this.test_match(tempMatch, rules[i]);
                            if (token !== false) {
                                return token
                            } else if (this._backtrack) {
                                match = false;
                                continue
                            } else {
                                return false
                            }
                        } else if (!this.options.flex) {
                            break
                        }
                    }
                }
                if (match) {
                    token = this.test_match(match, rules[index]);
                    if (token !== false) {
                        return token
                    }
                    return false
                }
                if (this._input === "") {
                    return this.EOF
                } else {
                    return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
                        text: "",
                        token: null,
                        line: this.yylineno
                    })
                }
            },

            // return next match that has a token
            lex: function lex() {
                "use strict";
                var r = this.next();
                if (r) {
                    return r
                } else {
                    return this.lex()
                }
            },

            // activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
            begin: function begin(condition) {
                "use strict";
                this.conditionStack.push(condition)
            },

            // pop the previously active lexer condition state off the condition stack
            popState: function popState() {
                "use strict";
                var n = this.conditionStack.length - 1;
                if (n > 0) {
                    return this.conditionStack.pop()
                } else {
                    return this.conditionStack[0]
                }
            },

            // produce the lexer rule set which is active for the currently active lexer condition state
            _currentRules: function _currentRules() {
                "use strict";
                if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
                    return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules
                } else {
                    return this.conditions["INITIAL"].rules
                }
            },

            // return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
            topState: function topState(n) {
                "use strict";
                n = this.conditionStack.length - 1 - Math.abs(n || 0);
                if (n >= 0) {
                    return this.conditionStack[n]
                } else {
                    return "INITIAL"
                }
            },

            // alias for begin(condition)
            pushState: function pushState(condition) {
                "use strict";
                this.begin(condition)
            },

            // return the number of states currently on the stack
            stateStackSize: function stateStackSize() {
                "use strict";
                return this.conditionStack.length
            },
            options: {},
            performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {

                var YYSTATE = YY_START;
                switch ($avoiding_name_collisions) {
                    case 0:
                        /* skip whitespace */
                        break;
                    case 1:
                        return 13;
                        break;
                    case 2:
                        return 13;
                        break;
                    case 3:
                        return 35;
                        break;
                    case 4:
                        return 30;
                        break;
                    case 5:
                        return 10;
                        break;
                    case 6:
                        return 11;
                        break;
                    case 7:
                        if (sheet.obj.type == 'cell') return 32;
                        return 40;


                        break;
                    case 8:
                        if (sheet.obj.type == 'cell') return 34;
                        return 40;


                        break;
                    case 9:
                        return 37;


                        break;
                    case 10:
                        return 30;
                        break;
                    case 11:
                        return 40;
                        break;
                    case 12:
                        return 40;
                        break;
                    case 13:
                        return 42;
                        break;
                    case 14:
                        /* skip whitespace */
                        break;
                    case 15:
                        return ' ';
                        break;
                    case 16:
                        return 41;
                        break;
                    case 17:
                        return 33;
                        break;
                    case 18:
                        return 38;
                        break;
                    case 19:
                        return 39;
                        break;
                    case 20:
                        return 26;
                        break;
                    case 21:
                        return 27;
                        break;
                    case 22:
                        return 25;
                        break;
                    case 23:
                        return 16;
                        break;
                    case 24:
                        return 28;
                        break;
                    case 25:
                        return 17;
                        break;
                    case 26:
                        return 18;
                        break;
                    case 27:
                        return 19;
                        break;
                    case 28:
                        return 21;
                        break;
                    case 29:
                        return 23;
                        break;
                    case 30:
                        return 22;
                        break;
                    case 31:
                        return 24;
                        break;
                    case 32:
                        return 'PI';
                        break;
                    case 33:
                        return 29;
                        break;
                    case 34:
                        return 7;
                        break;
                    case 35:
                        return 8;
                        break;
                    case 36:
                        return 9;
                        break;
                    case 37:
                        return '"';
                        break;
                    case 38:
                        return "'";
                        break;
                    case 39:
                        return "!";
                        break;
                    case 40:
                        return 15;
                        break;
                    case 41:
                        return 43;
                        break;
                    case 42:
                        return 44;
                        break;
                    case 43:
                        return 14;
                        break;
                    case 44:
                        return 5;
                        break;
                }
            },
            rules: [
                /^(?:\s+)/,
                /^(?:"(\\["]|[^"])*")/,
                /^(?:'(\\[']|[^'])*')/,
                /^(?:#[A-Za-z0-9_]+)/,
                /^(?:[A-Za-z]{1,}[A-Za-z_0-9]+(?=[(]))/,
                /^(?:([0]?[1-9]|1[0-2])[:][0-5][0-9]([:][0-5][0-9])?[ ]?(AM|am|aM|Am|PM|pm|pM|Pm))/,
                /^(?:([0]?[0-9]|1[0-9]|2[0-3])[:][0-5][0-9]([:][0-5][0-9])?)/,
                /^(?:\$[A-Za-z]+\$[0-9]+)/,
                /^(?:[A-Za-z]+[0-9]+)/,
                /^(?:[A-Za-z]+[:][A-Za-z]+)/,
                /^(?:[A-Za-z]+(?=[(]))/,
                /^(?:[A-Za-z]{1,}[A-Za-z_0-9]+)/,
                /^(?:[A-Za-z_]+)/,
                /^(?:[0-9]+)/,
                /^(?:\$)/,
                /^(?: )/,
                /^(?:[.])/,
                /^(?::)/,
                /^(?:;)/,
                /^(?:,)/,
                /^(?:\*)/,
                /^(?:\/)/,
                /^(?:-)/,
                /^(?:\+)/,
                /^(?:\^)/,
                /^(?:\()/,
                /^(?:\))/,
                /^(?:\[)/,
                /^(?:\])/,
                /^(?:>)/,
                /^(?:<)/,
                /^(?:NOT\b)/,
                /^(?:PI\b)/,
                /^(?:E\b)/,
                /^(?:TRUE\b)/,
                /^(?:FALSE\b)/,
                /^(?:NULL\b)/,
                /^(?:")/,
                /^(?:')/,
                /^(?:!)/,
                /^(?:=)/,
                /^(?:%)/,
                /^(?:[#])/,
                /^(?:[&])/,
                /^(?:$)/
            ],
            conditions: {
                "INITIAL": {
                    "rules": [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44],
                    "inclusive": true
                }
            }
        };
        return lexer;
    })();
    parser.lexer = lexer;

    function Parser() {
        this.yy = {};
    }
    Parser.prototype = parser;
    parser.Parser = Parser;
    return new Parser;
} //parserFactory

var formula = {
    
custom : {
},

 /**
 * date formula group.
 * adapted from stoic's formula.js (http://www.stoic.com/pages/formula)
 * with modification to adapt Calx environment
 * @type {Object}
 */
date: {
    DATE : function(year, month, day) {
        if(typeof (moment) == 'undefined'){
            return data.ERRKEY.momentRequired;
        }
        //@@@@@MAD
        // if(typeof(month) == 'undefined'){
        //     return moment(year);
        // }
        // return new Date(year, month - 1, day);
		
		return moment(new Date(year, month - 1, day)).format('YYYY-MM-DD'); //@@@@@MAD
    },

    //@@@@@MAD --removed functions --> DATEDIFF, DATEFORMAT, DATEVALUE, DAY
    DAYNAME : function(date){
        //return data.DAY_NAME[formula.date.WEEKDAY(date)-1]; //english //@@@@@MAD
        return moment(new Date(date)).format('dddd'); //german --moment local  //@@@@@MAD
    },

    //@@@@@MAD --removed functions --> DAYS, DAYS360

    //@@@@@MAD
    // EDATE : function(start_date, months) {
    //     if(typeof (moment) == 'undefined'){
    //         return data.ERRKEY.momentRequired;
    //     }
    //     return moment(new Date(start_date)).add('months', months).toDate();
    // },
    //@@@@@MAD
    EDATE : function(start_date, add) { //@@@@@MAD
        if(typeof (moment) == 'undefined'){
            return data.ERRKEY.momentRequired;
        }
        if(typeof (add) == 'undefined') { add = '+0days'; }

        const num = add.replace(/\D+/g, '');
		let period = add.replace(num, '').trim();
		console.log(add, num, period);
		
		period = period.replace('-', '').replace('+', '');
		//convert period to moment like
		if (period.toLowerCase() == 'd') period = 'days';
		if (period.toLowerCase() == 't') period = 'days';
		if (period.toLowerCase() == 'tag') period = 'days';
		if (period.toLowerCase() == 'tage') period = 'days';
		if (period.toLowerCase() == 'm') period = 'months';
		if (period.toLowerCase() == 'monat') period = 'months';
		if (period.toLowerCase() == 'monate') period = 'months';
		if (period.toLowerCase() == 'y') period = 'years';
		if (period.toLowerCase() == 'j') period = 'years';
		if (period.toLowerCase() == 'jahr') period = 'years';
		if (period.toLowerCase() == 'jahre') period = 'years';
		
		if (add.indexOf('-') != -1) {
			return moment(new Date(start_date)).subtract(num, period).format('YYYY-MM-DD');
		}
		else {
			return moment(new Date(start_date)).add(num, period).format('YYYY-MM-DD');
		}
    }, //@@@@@MAD

    //@@@@@MAD --removed functions --> EOMONTH, FROMNOW, HOUR, MINUTE, ISOWEEKNUM, MONTH, NETWORKDAYS, NETWORKDAYSINTL, NOW, SECOND, TIME, TIMEVALUE, TODAY, WEEKDAY, WEEKNUM, WORKDAY, WORKDAYINTL, YEAR, YEARFRAC 
},

math : {
    //@@@@@MAD --removed functions --> ABS, ACOS, ACOSH, ACOT, ACOTH, AGGREGATE, ARABIC, ASIN, ASINH, ATAN, ATAN2, ATANH, BASE, CEILING, CEILINGMATH, CEILINGPRECISE, COMBIN, COMBINA, COS, COSH, COT, COTH, CSC, CSCH, DECIMAL, DEGREES

    DIVIDE : function(num1, num2){
        if(num1 === '' || num2 === ''){
            return '';
        }

        if(num2 == 0){
            return '#DIV/0';
        }

        return parseFloat(num1)/parseFloat(num2);
    },
    //@@@@@MAD --removed functions --> EVEN, EXP, FACT, FACTDOUBLE, FLOOR, FLOORMATH, FLOORPRECISE, GCD, INT, ISEVEN, ISOCEILING, ISODD, LCM, LN, LOG, LOG10, MOD, MROUND, MULTINOMIAL
    MULTIPLY : function(num1, num2){
        if(num1 === '' || num2 === ''){
            return '';
        }

        num1 = isNaN(parseFloat(num1)) ? 0 : parseFloat(num1);
        num2 = isNaN(parseFloat(num2)) ? 0 : parseFloat(num2);

        return num1*num2;
    },

    //@@@@@MAD --removed functions --> ODD, PI
    POWER : function(number, power) {
        return Math.pow(number, power);
    },

    //@@@@@MAD --removed functions --> PRODUCT, QUOTIENT, RADIANS, RAND, RANDBETWEEN, ROUNDDOWN, ROUNDUP, SERIESSUM, SEC, SECH, SIGN, SIN, SINH, SQRT, SQRTPI, SUBTOTAL
    ROUND : function(number, digits) {
        return Math.round(number * Math.pow(10, digits)) / Math.pow(10, digits);
    },

    SUBTRACT : function(num1, num2){
        if(num1 === '' && num2 === ''){
            return '';
        }


        num1 = isNaN(parseFloat(num1)) ? 0 : parseFloat(num1);
        num2 = isNaN(parseFloat(num2)) ? 0 : parseFloat(num2);

        return num1 - num2;
    },


    SUM : function(){
        var cell, a, floatVal, stringVal = '', result = 0;

        for(a = 0; a < arguments.length; a++){
            if(typeof(arguments[a]) == 'object'){
                for(cell in arguments[a]){
                    stringVal   += (typeof(arguments[a][cell]) != 'undefined') ? arguments[a][cell] : '';
                    floatVal    = !isNaN(parseFloat(arguments[a][cell], 10)) ? parseFloat(arguments[a][cell], 10) : 0;
                    result      += floatVal;
                }
            }else{
                stringVal   += (typeof(arguments[a]) != 'undefined') ? arguments[a] : '';
                floatVal    = !isNaN(parseFloat(arguments[a], 10)) ? parseFloat(arguments[a], 10) : 0;
                result      += floatVal;
            }
        }

        if(result === 0 && $.trim(stringVal) === ''){
            return '';
        }else{
            return result;
        }
    },

    SUMIF : function(range, criteria, sum_range) {
        var result = 0;
        range = utility.objectToArray(range);

        if(typeof(sum_range) == 'undefined'){
            sum_range = range;
        } else {
            sum_range = utility.objectToArray(sum_range);
        }

        for(var i = 0; i < range.length; i++) {
			// console.log(4, this.evaluate(range[i] + criteria), sum_range[i]); //@@@@@MAD
            if (this.evaluate(range[i] + criteria)) {
                // result += sum_range[i]; //@@@@@MAD
                result += parseFloat(sum_range[i]);  //@@@@@MAD
             }
        }

        return result;
    },

    SUMIFS : function() {
        var criteria = (arguments.length - 1) / 2;
        var range = utility.objectToArray(arguments[0]);
        var result = 0;

        for (var i = 0; i < range.length; i++) {
            var fit = true;
            for (var j = 0; j < criteria; j++) {
                var criteria_clause = arguments[2 * j + 1];
                var criteria_range  = utility.objectToArray(arguments[2 * j + 2]);

                if (fit) {
                    fit = this.evaluate(criteria_range[i] + criteria_clause);
                }
            }
            result += (fit) ? range[i] : 0;
        }
        return result;
    },

    //@@@@@MAD --removed functions --> SUMPRODUCT, SUMSQ, SUMX2MY2, SUMX2PY2, SUMXMY2, TAN, TANH, TRUNC
},

 /**
 * financial formula group.
 * adapted from stoic's formula.js (http://www.stoic.com/pages/formula)
 * with modification to adapt Calx environment
 * @type {Object}
 */
financial: {
    //@@@@@MAD --removed functions --> ACCRINT, ACCRINTM, AMORDEGRC, AMORLINC, COUPDAYBS, COUPDAYS, COUPDAYSNC, COUPNCD, COUPNUM, COUPPCD, CUMIPMT, CUMPRINC, DB, DDB, DISC, DOLLARDE, DOLLARFR, DURATION, EFFECT, FV, FVSCHEDULE, INTRATE, IPMT, IRR, ISPMT, MDURATION, MIRR, NOMINAL, NPER, NPV, ODDFPRICE, ODDFYIELD, ODDLPRICE, ODDLYIELD, PDURATION, PMT, PPMT, PRICE, PRICEDISC, PRICEMAT, PV, RATE, RECEIVED, RRI, SLN, SYD, TBILLEQ, TBILLPRICE, TBILLYIELD, VDB, XIRR, XNPV, YIELD, YIELDDISC, YIELDMAT
},
    
statistic: {
    //@@@@@MAD --removed functions --> AVEDEV

    AVERAGE : function() {
        var range = utility.arrayMerge(arguments);
        var n = range.length;
        var count = 0;
        var sigma = 0;
        var floatVal = 0;
        for (var i = 0; i < n; i++) {
            if (range[i] !== true && range[i] !== false) {
                floatVal = parseFloat(range[i]);
                sigma += isNaN(floatVal) ? 0 : floatVal;
                count++;
            }
        }
        return sigma / count;
    },

    AVERAGEA : function() {
        if(typeof(jStat) == 'undefined'){
            return data.ERRKEY.jStatRequired;
        }
        return jStat.mean(utility.arrayMerge(arguments));
    },

    AVERAGEIF : function(range, criteria, average_range) {
        // average_range = (typeof average_range === 'undefined') ? range : average_range; //@@@@@MAD
		range = utility.objectToArray(range); //@@@@@MAD
        average_range = (typeof average_range === 'undefined') ? range : utility.objectToArray(average_range); //@@@@@MAD

        var average_count = 0;
        var result = 0;
        for (var i = 0; i < range.length; i++) {
            //@@@@@MAD
            // if (eval(range[i] + criteria)) {
            //     result += average_range[i];
            //@@@@@MAD
            if (this.evaluate(range[i] + criteria)) {
                result += parseFloat(average_range[i]);
                average_count++;
				//console.log(3, range[i], criteria, eval(range[i] + criteria), result, average_count);
            } //@@@@@MAD
        }
        return result / average_count;
    },

    AVERAGEIFS : function() {
        var criteria = (arguments.length - 1) / 2;
        var range = arguments[0];
        var count = 0;
        var result = 0;
        for (var i = 0; i < range.length; i++) {
            var fit = true;
            for (var j = 0; j < criteria; j++) {
                if (!eval(arguments[2 * j + 1][i] + arguments[2 * j + 2])) {
                    fit = false;
                }
            }
            if (fit) {
                result += range[i];
                count++;
            }
        }
        return result / count;
    },

    //@@@@@MAD --removed functions --> BETADIST, BETAINV, BINOMDIST, BINOMDISTRANGE, BINOMINV, CHISQDIST, CHISQDISTRT, CHISQINV, CHISQINVRT, CHISQTEST, CONFIDENCENORM, CONFIDENCET, CORREL, COUNT, COUNTA, COUNTBLANK, COUNTIF, COUNTIFS, COUNTUNIQUE, COVARIANCEP, COVARIANCES, DEVSQ, EXPONDIST, FDIST, FDISTRT, FINV, FINVRT, FTEST, FISHER, FISHERINV, FORECAST, FREQUENCY, GAMMA, GAMMADIST, GAMMAINV, GAMMALN, GAMMALNPRECISE, GAUSS, GEOMEAN, GROWTH, HARMEAN, HYPGEOMDIST, INTERCEPT, KURT, LARGE, LINEST, LOGEST, LOGNORMDIST, LOGNORMINV
    MAX : function() {
        var range = utility.arrayMerge(arguments);
        var n = range.length;
        var max = (n > 0) ? range[0] : 0;
        for (var i = 0; i < n; i++) {
            max = (range[i] > max && (range[i] !== true) && (range[i] !== false)) ? range[i] : max;
        }
        return max;
    },

    MAXA : function() {
        var range = utility.arrayMerge(arguments);
        return (range.length > 0) ? Math.max.apply(Math, range) : 0;
    },

    //@@@@@MAD --removed functions --> MEDIAN
    MIN : function() {
        var range = utility.arrayMerge(arguments);
        var n = range.length;
        var min = (n > 0) ? range[0] : 0;
        for (var i = 0; i < n; i++) {
            min = (range[i] < min && (range[i] !== true) && (range[i] !== false)) ? range[i] : min;
        }
        return min;
    },

    MINA : function() {
        var range = utility.arrayMerge(arguments);
        return (range.length > 0) ? Math.min.apply(Math, range) : 0;
    },

    //@@@@@MAD --removed functions --> MODEMULT, MODESNGL, NEGBINOMDIST, NORMDIST, NORMINV, NORMSDIST, NORMSINV, PEARSON, PERCENTILEEXC, PERCENTILEINC, PERCENTRANKEXC, PERCENTRANKINC, PERMUT, PERMUTATIONA, PHI, POISSONDIST, PROB, QUARTILEEXC, QUARTILEINC, RANKAVG, RANKEQ, RSQ, SKEW, SKEWP, SLOPE, SMALL, STANDARDIZE
    STDEVA : function() {
        var range = utility.arrayMerge(arguments);
        var n = range.length;
        var sigma = 0;
        var mean = jStat.mean(range);
        for (var i = 0; i < n; i++) {
            sigma += Math.pow(range[i] - mean, 2);
        }
        return Math.sqrt(sigma / (n - 1));
    },

    STDEVP : function() {
        var range = utility.arrayMerge(arguments);
        var n = range.length;
        var sigma = 0;
        var count = 0;
        var mean = formula.statistic.AVERAGE(range);
        for (var i = 0; i < n; i++) {
            if (range[i] !== true && range[i] !== false) {
                sigma += Math.pow(range[i] - mean, 2);
                count++;
            }
        }
        return Math.sqrt(sigma / count);
    },

    //@@@@@MAD
    STDEVPN0 : function() { // no zero vals
        var range = utility.arrayMerge(arguments);
        range = utility.removeFalseFromArray(range); //Remove null, 0, blank, false, undefined and NaN values from an array
        var n = range.length;
        var sigma = 0;
        var count = 0;
        var mean = formula.statistic.AVERAGE(range);
        for (var i = 0; i < n; i++) {
            if (range[i] !== true && range[i] !== false) {
                sigma += Math.pow(range[i] - mean, 2);
                count++;
            }
        }
        return Math.sqrt(sigma / count);
    }, //@@@@@MAD

    STDEVPA : function() {
        if(typeof(jStat) == 'undefined'){
            return data.ERRKEY.jStatRequired;
        }
        var range = utility.arrayMerge(arguments);
        var n = range.length;
        var sigma = 0;
        var mean = jStat.mean(range);
        for (var i = 0; i < n; i++) {
            sigma += Math.pow(range[i] - mean, 2);
        }
        return Math.sqrt(sigma / n);
    },

    STDEVS : function() {
        var range = utility.arrayMerge(arguments);
        var n = range.length;
        var sigma = 0;
        var count = 0;
        var mean = formula.statistic.AVERAGE(range);
        for (var i = 0; i < n; i++) {
            if (range[i] !== true && range[i] !== false) {
                sigma += Math.pow(range[i] - mean, 2);
                count++;
            }
        }
        return Math.sqrt(sigma / (count - 1));
    },
    //@@@@@MAD --removed functions --> STEYX, TDIST, TDIST2T, TDISTRT, TINV, TINV2T, TTEST, TREND, TRIMMEAN, VARA, VARP, VARPA, VARS, WEIBULLDIST, ZTEST
},

 /**
 * logical formula group.
 * adapted from stoic's formula.js (http://www.stoic.com/pages/formula)
 * with modification to adapt Calx environment
 * @type {Object}
 */
logical : {
    AND : function() {
        var result = true;
        for (var i = 0; i < arguments.length; i++) {
            if (!arguments[i]) {
                result = false;
            }
        }
        return result;
    },

    //@@@@@MAD --removed functions --> CHOOSE

    FALSE : function(){
        return false;
    },

    IF : function(test, then_value, otherwise_value) {
        if (test) {
            return (typeof then_value === 'undefined') ? true : then_value;
        } else {
            return (typeof otherwise_value === 'undefined') ? true : otherwise_value;
        }
    },

    IFERROR : function(value, value_if_error) {
        return (data.ERROR.indexOf(value) >= 0) ? value_if_error : value;
    },

    IFNA : function(value, value_if_na) {
        return (value === '#N/A') ? value_if_na : value;
    },

    NOT : function(logical) {
        return !logical;
    },

    OR : function() {
        var result = false;
        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i]) {
                result = true;
            }
        }
        return result;
    },

    //@@@@@MAD --removed functions --> SWITCH
    
    TRUE : function() {
        return true;
    },

    XOR : function() {
        var result = 0;
        for (var i = 0; i < arguments.length; i++) {
            if (arguments[i]) {
                result++;
            }
        }
        return (Math.floor(Math.abs(result)) & 1) ? true : false;
    },

    NULL : function(){
        return null;
    }


},
geometry : {
    
},
text:{
    CONCAT : function(){
        var result = '', cell;

        for(cell in arguments){
            if(typeof(arguments[cell]) == 'object'){
                result += formula.text.CONCAT.apply(this, arguments[cell]);
            }else{
                result += arguments[cell];
            }
        }

        return result;
    },

    //@@@@@MAD --removed functions --> CHAR, CLEAN, CODE, CONCATENATE, DOLLAR, EXACT, FIND, FIXED, HTML2TEXT, HUMANIZE
    JOIN : function(array, separator) {
        return array.join(separator);
    },

    LEFT : function(text, number) {
        number = (typeof number === 'undefined') ? 1 : number;
        return text ? text.substring(0, number) : null;
    },

    LEN : function(text) {
        return (text+'').length;
    },

    LOWER : function(text) {
        return text ? text.toLowerCase() : text;
    },

    MID : function(text, start, number) {
        return text.substring(start - 1, number);
    },

    //@@@@@MAD --removed functions --> NUMBERVALUE, PROPER, REGEXEXTRACT, REGEXMATCH, REGEXREPLACE, REPLACE, REPT

    RIGHT : function(text, number) {
        number = (typeof number === 'undefined') ? 1 : number;
        return text ? text.substring(text.length - number) : null;
    },

    //@@@@@MAD --removed functions --> ROMAN, SEARCH, SPLIT, SUBSTITUTE, T, TEXT, TRIM, UNICHAR, UNICODE

    UPPER : function(text) {
        return text.toUpperCase();
    },

    //@@@@@MAD --removed functions --> VALUE
},
trigonometry:{
    
},
general: {
    //@@@@@MAD --removed functions --> VLOOKUP, HLOOKUP, LOOKUP, SERVER, GRAPH
},
engineering: {
    //@@@@@MAD --removed functions --> BIN2DEC, BIN2HEX, BIN2OCT, BITAND, BITLSHIFT, BITOR, BITRSHIFT, BITXOR, COMPLEX, CONVERT, DEC2BIN, DEC2HEX, DEC2OCT, DELTA, ERF, ERFC, ERFCPRECISE, ERFPRECISE, GESTEP, HEX2BIN, HEX2DEC, HEX2OCT, IMABS, IMAGINARY, IMARGUMENT, IMCONJUGATE, IMCOS, IMCOSH, IMCOT, IMCSC, IMCSCH, IMDIV, IMEXP, IMLN, IMLOG10, IMLOG2, IMPOWER, IMPRODUCT, IMREAL, IMSEC, IMSECH, IMSIN, IMSINH, IMSQRT, IMSUB, IMSUM, IMTAN, OCT2BIN, OCT2DEC, OCT2HEX
},

user_defined : {
}

}; //formula

var utility = {
	//@@@@@MAD
	//Remove null, 0, blank, false, undefined and NaN values from an array
    removeFalseFromArray: function(array) { //MAD
		var newArr = [];
		for (var i = 0; i < array.length; i++) {
			if (array[i]) {
				newArr.push(array[i]);
			}
		}
		return newArr;
	}, //@@@@@MAD
	
    /**
     * translate numeric to alphabet
     * @param  {integer} num    numeric value translated to alphabet
     * @return {string}         alphabet representation of the value
     */
    toChr: function(num) {
        var s = "";
        num = num - 1;
        while (num >= 0) {
            s = String.fromCharCode(num % 26 + 97) + s;
            num = Math.floor(num / 26) - 1;
        }
        return s.toUpperCase();
    },

    /**
     * translate alphabet to numeric, A => 1, B => 2, Z => 26, AA => 27 etc
     * @param  {string} chr     Alphabet [A-Z]
     * @return {integer}        Integer representation of the alphabet
     */
    toNum: function(chr) {
        chr = chr.split('');
        var base = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split(''),
            i, j, result = 0;

        for (i = 0, j = chr.length - 1; i < chr.length; i += 1, j -= 1) {
            result += Math.pow(base.length, j) * (base.indexOf(chr[i]) + 1);
        }
        return result;
    },

    /**
     * translate cellStart:cellStop to array containing all cell in range
     * e.g A1:B3 => [A1, A2, A3, B1, B2, B3]
     * @return {array} array containing all address in range
     */
    cellRange: function(addressStart, addressStop) {
        var alpha = /[A-Z]+/,
            num = /[0-9]+/,
            cellStart = addressStart.toUpperCase(),
            cellStop = addressStop.toUpperCase(),
            alphaAxisStart = this.toNum(cellStart.match(alpha)[0]),
            alphaAxisStop = this.toNum(cellStop.match(alpha)[0]),
            numAxisStart = parseInt(cellStart.match(num)[0], 10),
            numAxisStop = parseInt(cellStop.match(num)[0], 10),
            cellRange = [],
            cellAddress,
            row,
            col;

        if(alphaAxisStart < alphaAxisStop){
            for (col = alphaAxisStart; col <= alphaAxisStop; col++) {
                if(numAxisStart < numAxisStop){
                    for (row = numAxisStart; row <= numAxisStop; row++) {
                        cellAddress = this.toChr(col) + row;
                        cellRange.push(cellAddress);
                    }
                }else{
                    for (row = numAxisStart; row >= numAxisStop; row--) {
                        cellAddress = this.toChr(col) + row;
                        cellRange.push(cellAddress);
                    }
                }
            }
        }else{
            for (col = alphaAxisStart; col >= alphaAxisStop; col--) {
                if(numAxisStart < numAxisStop){
                    for (row = numAxisStart; row <= numAxisStop; row++) {
                        cellAddress = this.toChr(col) + row;
                        cellRange.push(cellAddress);
                    }
                }else{
                    for (row = numAxisStart; row >= numAxisStop; row--) {
                        cellAddress = this.toChr(col) + row;
                        cellRange.push(cellAddress);
                    }
                }
            }
        }

        return cellRange;
    },

    /**
     * taken from Formula.VALIDBIN of stoic's formula.js (http://www.stoic.com/pages/formula)
     * check if number is in valid binary format
     * @param  {string}  number [the binary number]
     * @return {Boolean}        [true if valid, false if invalid]
     */
    isValidBinary: function(number) {
        return (/^[01]{1,10}$/).test(number);
    },

    /**
     * String repeater, taken from underscore string (https://github.com/epeli/underscore.string)
     * @param  {[type]} str [description]
     * @param  {[type]} qty [description]
     * @return {[type]}     [description]
     */
    strRepeat: function(str, qty) {
        if (qty < 1) return '';
        var result = '';
        while (qty > 0) {
            if (qty & 1) result += str;
            qty >>= 1, str += str;
        }
        return result;
    },

    repeat: function(str, qty, separator) {
        if (str == null) {
            return '';
        }

        qty = ~~qty;

        // using faster implementation if separator is not needed;
        if (separator == null) {
            return this.strRepeat(String(str), qty);
        }

        // this one is about 300x slower in Google Chrome
        for (var repeat = []; qty > 0; repeat[--qty] = str) {}
        return repeat.join(separator);
    },

    unique: function(array) {
        return array.reduce(function(p, c) {
            if (p.indexOf(c) < 0) p.push(c);
            return p;
        }, []);
    },

    initial : function(array, n, guard) {
        return Array.prototype.slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    },

    rest : function(array, n, guard) {
        return Array.prototype.slice.call(array, n == null || guard ? 1 : n);
    },

    /** end of underscore func */

    arrayMerge: function(args) {
        var a, i, result = [];
        for (i = 0; i < args.length; i++) {
            if (typeof(args[i]) == 'object') {
                for (a in args[i]) {
                    if($.trim(args[i][a]) !== ''){
                        result = result.concat(args[i][a]);
                    }
                }
            } else {
                if($.trim(result.concat(args[i])) !== ''){
                    result = result.concat(args[i]);
                }
            }
        }
        return result;
    },

    toArray: function(args) {
        return Array.prototype.slice.call(args, 0);
    },

    /**
     * Converting object into plain array
     * @param  {object} obj Object need to be converted
     * @return {array}      Plain array
     */
    objectToArray: function(obj){
        var ar = [], a;

        for(a in obj){
            ar.push(obj[a]);
        }

        return ar;
    },

    /**
     * remove empty cell from cell range collection
     * @param  {object} cellRange
     * @return {object} trimmed cellRange
     */
    trimEmptyCell : function(cellRange){
        var result = {};

        for(var a in cellRange){
            if($.trim(cellRange[a]) !== ''){
                result[a] = cellRange[a];
            }
        }

        return result;
    },

    cleanFloat: function(number) {
        var power = Math.pow(10, 14);
        return Math.round(number * power) / power;
    },

    countIn: function(range, value) {
        var result = 0;
        for (var i = 0; i < range.length; i++) {
            if (range[i] === value) {
                result++;
            }
        }
        return result;
    },

    /**
     * convert range {A1: val1, A2: val2, B1: val3, B2: val4} into 2 dimensional table array
     * [
     *     [val1, val2],
     *     [val3, val4]
     * ]
     *
     * @param  {object} cellRange [description]
     * @return {array}            [description]
     */
    rangeToTable : function(cellRange){
        var cell, col,
            row = 0,
            alphaPattern = /[A-Z]+/,
            numPattern = /[0-9]+/,
            arrayTable = [],
            resultTable = [];

        for(cell in cellRange){

            col = this.toNum(cell.match(alphaPattern)[0])-1;
            row = parseInt(cell.match(numPattern)[0], 10)-1;

            if(typeof arrayTable[row] == 'undefined'){
                arrayTable[row] = [];
            }

            arrayTable[row][col] = cellRange[cell];
        }

        var resultRow = 0, rowLength = arrayTable.length, colLength;
        for (row = 0; row < rowLength; row++){
            if(typeof(arrayTable[row]) != 'undefined'){
                colLength = arrayTable[row].length;

                if(typeof(resultTable[resultRow]) == 'undefined'){
                    resultTable[resultRow] = [];
                }

                for(col = 0; col < colLength; col++ ){
                    if(typeof(arrayTable[row][col]) != 'undefined'){
                        resultTable[resultRow].push(arrayTable[row][col]);
                    }
                }

                resultRow++;
            }
        }

        return resultTable;
    },

    /**
     * transpose horizontal table to be vertical table, or vice-versa
     * e.g
     *     [[1,2,3,4],
     *      [1,2,3,4]]
     *
     * to be
     *     [[1,1],
     *      [2,2],
     *      [3,3],
     *      [4,4]]
     */
    transposeTable : function(table){
        var row, col, rowLength, colLength, newTable;

        rowLength = table.length;
        newTable  = [];

        for(row = 0; row < rowLength; row++){
            colLength = table[row].length;

            for(col = 0; col < colLength; col++){
                if(typeof(newTable[col]) == 'undefined'){
                    newTable[col] = [];
                }

                newTable[col].push(table[row][col]);
            }
        }

        return newTable;

    }
};

var data = {
    MEMOIZED_FACT : [],

    SQRT2PI : 2.5066282746310002,

    WEEK_STARTS : [
      undefined,
      0,
      1,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      undefined,
      1,
      2,
      3,
      4,
      5,
      6,
      0
    ],

    WEEK_TYPES : [
      [],
      [1, 2, 3, 4, 5, 6, 7],
      [7, 1, 2, 3, 4, 5, 6],
      [6, 0, 1, 2, 3, 4, 5],
      [],
      [],
      [],
      [],
      [],
      [],
      [],
      [7, 1, 2, 3, 4, 5, 6],
      [6, 7, 1, 2, 3, 4, 5],
      [5, 6, 7, 1, 2, 3, 4],
      [4, 5, 6, 7, 1, 2, 3],
      [3, 4, 5, 6, 7, 1, 2],
      [2, 3, 4, 5, 6, 7, 1],
      [1, 2, 3, 4, 5, 6, 7]
    ],

    WEEKEND_TYPES : [
      [],
      [6, 0],
      [0, 1],
      [1, 2],
      [2, 3],
      [3, 4],
      [4, 5],
      [5, 6],
      undefined,
      undefined,
      undefined,
      [0],
      [1],
      [2],
      [3],
      [4],
      [5],
      [6]
    ],

    DAY_NAME : [
        'Sunday',
        'Monday',
        'Thuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday'
    ],

    ERROR : [
        '#DIV/0!',
        '#N/A',
        '#NAME?',
        '#NUM!',
        '#NULL!',
        '#REF!',
        '#VALUE!',
        '#ERROR!',
        '#ERROR_MOMENT_JS_REQUIRED!',
        '#ERROR_JSTAT_JS_REQUIRED!',
        '#ERROR_AJAX_URL_REQUIRED!',
        '#ERROR_SEND_REQUEST!',
        '#UNDEFINED_VARIABLE!'
    ],

    ERRKEY : {
        jStatRequired : '#ERROR_JSTAT_JS_REQUIRED!',
        momentRequired : '#ERROR_MOMENT_JS_REQUIRED!',
        ajaxUrlRequired : '#ERROR_AJAX_URL_REQUIRED!',
        sendRequestError : '#ERROR_SEND_REQUEST!'
    },

    VARIABLE : {},

    SELF_RENDER_FORMULA : [
        'GRAPH'
    ]
}

/**
 * cell hold single element with formula and value information
 * @param  {sheet}      sheet       the sheet object where the cell is belong to
 * @param  {element}    element     dom element represent the cell (optional)
 * @return {void}
 */
function cell(sheet, element, address){
    this.sheet = sheet;

    this.value              = null;
    this.formattedValue     = null;
    this.computedValue      = null;
    this.floatValue         = null;
    this.affected           = false;
    this.processed          = false;
    this.dependencies       = {};
    this.dependant          = {};
    this.conditionalStyle   = false;
    this.address            = '';
    this.remoteDependency   = false;
    this.isCheckbox         = false;

    /** set cell element, is it in dom, or in memory */
    if(typeof(element) != 'undefined'){
        this.el = $(element);
    }else{
        this.el = false;
        this.address = typeof(address) != 'undefined' ? address : '';
    }

    this.init();
};

cell.fx = cell.prototype;
/**
 * Initialize the cell object, preparing all necessary variables
 * @return {void}
 */
cell.fx.init = function(){
    var $address = (this.el) ? this.el.attr('data-cell') : this.address,
        $formula = (this.el) ? this.el.attr('data-formula') : '',
        $format  = (this.el) ? this.el.attr('data-format') : false,
        $value   = (this.el) ? this.el.val() : null,
        tagName  = (this.el) ? this.el.prop('tagName').toLowerCase() : '';

    /** assign address if data-cell is not present */
    if(!$address || $.trim($address) == ''){
        $address = 'CALX'+this.sheet.counter;
        if(this.el) {
            this.el.attr('data-cell', $address);
        }
        this.sheet.counter++;
    }else{
        $address = $address.toUpperCase()
    }

    /** set the formula as false if data-formula exists, but empty */
    if(!$formula || $.trim($formula) == ''){
        $formula = false;
    }else{
        $formula = $formula.replace('&quot;', '"')
                           .replace('&#39;', "'")
                           .replace('&#34;', '"')
    }

    if(tagName == 'input' && (this.el.attr('type') == 'checkbox' || this.el.attr('type') == 'radio')){
        var uncheckedVal = this.el.attr('data-unchecked');
            uncheckedVal = (typeof(uncheckedVal) == 'undefined') ? '' : uncheckedVal;

        $value = (this.el.prop('checked')) ? this.el.val() : uncheckedVal;
        this.isCheckbox = true;
    }

    if(this.el && this.formTags.indexOf(tagName) == -1){
        $value = this.el.text();
    }

    /** fallback to default format where data-format is not present or empty */
    if($format === false || typeof($format) === 'undefined'){
        $format = this.sheet.config.defaultFormat;
    }

    this.formula    = $formula;
    this.format     = $format;
    this.address    = $address;


    //console.log('cell[#'+this.sheet.elementId+'!'+$address+'] : Initializing the cell');
    if($format && typeof(numeral) != 'undefined' && $.trim($value) !== ''){
        var rawValue = numeral().unformat($value);

        if($format.indexOf('%') > -1 && ($value).indexOf('%') == -1){
            rawValue = rawValue/100;

        }
    }else{
        rawValue = ($.isNumeric($value)) ? parseFloat($value) : $value;
    }

    this.setValue(rawValue);

    if($.trim($value) != '' && $.isNumeric($value)){
        this.renderComputedValue();
    }
    //this.attachEvent();
};

/**
 * calculate cells formula and process dependant
 */
cell.fx.calculate  = function(triggerEvent, renderComputedValue){
    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : calculating result of ['+this.formula+']');
    triggerEvent = (typeof triggerEvent == 'undefined') ? true : triggerEvent;
    renderComputedValue = (typeof renderComputedValue == 'undefined') ? true : renderComputedValue;

    /* clear list of affected cell */
    this.sheet.clearAffectedCell();

    if(this.sheet.config.autoCalculate && triggerEvent && typeof(this.sheet.config.onBeforeCalculate) == 'function'){
        this.sheet.config.onBeforeCalculate.call(this.sheet);
    }

    calx.isCalculating = true;
    this.evaluateFormula();

    for(var a in this.dependant){
        this.dependant[a].processDependant();
    }

    for(var a in this.sheet.dependant){
        this.sheet.dependant[a].calculate(false, false);
    }

    calx.isCalculating = false;


    if(this.sheet.hasRelatedSheet()){
        for(a in this.sheet.cells){
            //console.log('recalculating cell');
            if(this.sheet.cells[a].hasRemoteDependency()){
                this.sheet.cells[a].evaluateFormula();
                this.sheet.cells[a].processDependant();
                this.sheet.cells[a].renderComputedValue();

                //console.log('recalculating cell #'+this.sheet.el.attr('id')+'!'+a+'='+this.sheet.cells[a].getValue());
            }
        }
    }

    if(this.sheet.config.autoCalculate && triggerEvent && typeof(this.sheet.config.onAfterCalculate) == 'function'){
        this.sheet.config.onAfterCalculate.call(this.sheet);
    }

    if(this.sheet.config.autoCalculate && triggerEvent && typeof(this.sheet.config.onBeforeRender) == 'function'){
        this.sheet.config.onBeforeRender.call(this.sheet);
    }

    if(renderComputedValue){
        this.renderComputedValue();
    }

    if(this.sheet.config.autoCalculate && triggerEvent && typeof(this.sheet.config.onAfterRender) == 'function'){
        this.sheet.config.onAfterRender.call(this.sheet);
    }

    return this;
};

/**
 * build inter-cell dependency and dependant list, used for triggerring calculation that related to other cell
 * @return {void}
 */
cell.fx.buildDependency = function(){
    var pattern = {
            remoteCellRange : /\#[A-Za-z0-9_]+\s*!\s*[A-Za-z]+[0-9]+\s*:\s*[A-Za-z]+[0-9]+/g,
            remoteCell      : /\#[A-Za-z0-9_]+\s*!\s*[A-Za-z]+[0-9]+/g,
            cellRange       : /[A-Za-z]+[0-9]+\s*:\s*[A-Za-z]+[0-9]+/g,
            //cell            : /[A-Z]+[0-9]+/g  //@@@@@MAD
            cell            : /[A-Za-z]+[0-9]+/g  //@@@@@MAD
        },
        formula     = this.formula,
        sheetKey    = '#'+this.sheet.el.attr('id'),
        cellAddress = this.address,
        dependencies,
        a, i, j, key,
        formulaPart,
        cellStart,
        cellStop,
        cellPart,
        cellObject,
        cellMatch,
        sheetId,
        sheetIdentifier;

    /** clear up the dependant and dependency reference */
    for(a in this.dependencies){

        /** remove self from dependant registry in dependencies list before removing */
        if(a.indexOf('#') === -1){
            this.dependencies[a].removeDependant(cellAddress);
        }else{
            this.dependencies[a].removeDependant(sheetKey+'!'+cellAddress);
        }

        /** remove cell from dependencies list after removing itself from dependant registry */
        delete this.dependencies[a];
    }


    /** if formula exist, start scanning cell address inside the formula */
    if(formula){
        /** searching for cells in formula */
        for(a in pattern){
            cellMatch   = formula.match(pattern[a]);
            formula     = formula.replace(pattern[a], '');

            if(null !== cellMatch){
                switch(a){
                    /* First round, find the remote cell range and take it from formula */
                    case "remoteCellRange":
                        for(i = 0; i < cellMatch.length; i++){
                            formulaPart = cellMatch[i].split('!');
                            sheetId     = $.trim(formulaPart[0]);
                            cellPart    = formulaPart[1].split(':');
                            cellStart   = $.trim(cellPart[0]);
                            cellStop    = $.trim(cellPart[1]);

                            /** list all cells in range as dependencies */
                            dependencies = this.sheet.getRemoteCellRange(sheetId, cellStart, cellStop);

                            /** get the calx identifier of the remote sheet */
                            sheetIdentifier = $(sheetId).attr('data-calx-identifier');


                            /** if not identified yet, init calx on it and get the identifier */
                            if(typeof(sheetIdentifier) == 'undefined' || typeof(calx.sheetRegistry[sheetIdentifier]) == 'undefined'){
                                $(sheetId).calx();

                                sheetIdentifier = $(sheetId).attr('data-calx-identifier');
                            }

                            /** build dependency relationship to each sheet */
                            if(typeof(sheetIdentifier) !='undefined' && typeof(calx.sheetRegistry[sheetIdentifier]) != 'undefined'){
                                calx.sheetRegistry[sheetIdentifier].registerDependant(this.sheet);
                                this.sheet.registerDependency(calx.sheetRegistry[sheetIdentifier]);
                            }

                            /** build dependency relationship on current cell and it's dependencies */
                            for(j in dependencies){
                                key = sheetId+'!'+j;
                                if(typeof(this.dependencies[key]) == 'undefined' && false !== dependencies[j]){
                                    this.hasRemoteDependency(true);
                                    this.dependencies[key] = dependencies[j];
                                    dependencies[j].registerDependant(sheetKey+'!'+this.getAddress(), this);
                                }
                            }
                        }
                        break;

                    case "remoteCell":
                        for(i = 0; i < cellMatch.length; i++){
                            formulaPart = cellMatch[i].split('!');
                            sheetId     = $.trim(formulaPart[0]);
                            cellPart    = $.trim(formulaPart[1]);

                            dependencies = this.sheet.getRemoteCell(sheetId, cellPart);
                            sheetIdentifier = $(sheetId).attr('data-calx-identifier');

                            if(typeof(sheetIdentifier) == 'undefined' || typeof(calx.sheetRegistry[sheetIdentifier]) == 'undefined'){
                                $(sheetId).calx();
                            }

                            if(typeof(sheetIdentifier) !='undefined' && typeof(calx.sheetRegistry[sheetIdentifier]) != 'undefined'){
                                calx.sheetRegistry[sheetIdentifier].registerDependant(this.sheet);
                                this.sheet.registerDependency(calx.sheetRegistry[sheetIdentifier]);
                            }

                            key = sheetId+'!'+cellPart;
                            if(typeof(this.dependencies[key]) == 'undefined' && false !== dependencies){
                                this.hasRemoteDependency(true);
                                this.dependencies[key] = dependencies;
                                dependencies.registerDependant(sheetKey+'!'+this.getAddress(), this);

                            }
                        }
                        break;

                    case "cellRange":
                        for(i = 0; i < cellMatch.length; i++){
                            cellPart    = cellMatch[i].split(':');
                            cellStart   = $.trim(cellPart[0]);
                            cellStop    = $.trim(cellPart[1]);

                            dependencies = this.sheet.getCellRange(cellStart, cellStop);
                            for(j in dependencies){
                                if(typeof(this.dependencies[j]) == 'undefined' && false !== dependencies[j]){
                                    this.dependencies[j] = dependencies[j];
                                    dependencies[j].registerDependant(this.getAddress(), this);

                                }
                            }
                        }
                        break;

                    case "cell":
                        for(i = 0; i < cellMatch.length; i++){
                            cellPart    = cellMatch[i];

                            dependencies = this.sheet.getCell(cellPart);
                            if(typeof(this.dependencies[cellPart]) == 'undefined' && false !== dependencies){
                                this.dependencies[cellPart] = dependencies;
                                dependencies.registerDependant(this.getAddress(), this);

                            }
                        }
                        break;
                }
            }
        }
    }

    return this;

    //var dlist = [];
    //for(a in this.dependencies){
    //    dlist.push(a);
    //}
    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] :  Building dependency list '+dlist);
};

/**
 * remove key from the dependency list
 * @param  {string} key [the dependency key, can be cellAddress, or #sheet>cellAddress]
 * @return {void}
 */
cell.fx.removeDependency = function(key){
    if(typeof(this.dependencies[key]) != 'undefined'){
        delete this.dependencies[key];
    }
};

/**
 * process cell's dependency list and mark it as processed
 * @param  {bool} selfRender  [set render itself or not]
 * @param  {bool} childRender [set render child as well or not]
 * @return {void}
 */
cell.fx.processDependency = function(){
    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : processing dependency');

    //selfRender  = (typeof(selfRender) == 'undefined') ? false : selfRender;
    //childRender = (typeof(childRender) == 'undefined') ? false : childRender;

    /**
     * process all affected dependencies first, then evaluate the formula
     * mark each cell as processed by setting the processed flag as true
     */
    if(false == this.isProcessed()){
        //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : processing flag is ['+this.processed+'], processing...')
        for (var a in this.dependencies){
            if(false == this.dependencies[a].isProcessed()){
                this.dependencies[a].processDependency();
            }
        }

        this.evaluateFormula();
        this.setProcessed(true);

        if(this.sheet.affectedCell.indexOf(this.address) == -1){
            this.sheet.affectedCell.push(this.address);
            //console.log(this.sheet.affectedCell);
        }
    }else{
        //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : processing flag is ['+this.processed+'], leaving...')
    }

    //if(selfRender){
    //    this.renderComputedValue();
    //}
};

cell.fx.registerDependant = function(key, cell){
    if(typeof(this.dependant[key]) == 'undefined' && cell){
        this.dependant[key] = cell;
    }
};

cell.fx.removeDependant = function(key){
    if(typeof(this.dependant[key]) != 'undefined'){
        delete this.dependant[key];
    }
};

/**
 * Process all cell that depend on this cell once this cel value is updated
 *
 * @return {[type]} [description]
 */
cell.fx.processDependant = function(){
    var $continue;
    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : processing dependants');


    //prefix       = (typeof(prefix) == 'undefined') ? '--' : prefix;
    //selfRender   = (typeof(selfRender) == 'undefined') ? false : selfRender;
    //parentRender = (typeof(parentRender) == 'undefined') ? false : parentRender;

    if(false === this.isProcessed() || true === calx.isCalculating){
        //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : processing flag is ['+this.processed+'], processing...')

        this.processDependency();
        //console.log((new Date()).valueOf());
        //this.evaluateFormula();

        for(var a in this.dependant){
            //prefix = prefix+'--';
            //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : processing dependant ['+a+']');
            if(!this.dependant[a].isProcessed()){
                $continue = this.dependant[a].processDependant();
                if(false === $continue){
                    return $continue;
                }
            }else{
                //console.log(a+' is already processed, leaving...');
            }
        }

        this.setAffected(false);
        this.setProcessed(true);

        if(this.sheet.affectedCell.indexOf(this.address) == -1){
            this.sheet.affectedCell.push(this.address);
            //console.log(this.sheet.affectedCell);
        }
    }else{
        //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : processing flag is ['+this.processed+'], leaving...')
        return false;
    }

};

cell.fx.hasRemoteDependency = function(status){
    if(typeof(status) == 'undefined'){
        return this.remoteDependency
    }else{
        this.remoteDependency = status;
    }
};

/**
 * render calculated value or final value to the element bound to this cell
 * @return {void}
 */
cell.fx.renderComputedValue = function(){
    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : rendering computed value');
	
    if(this.formula && this.formula.substring(0,5).toLowerCase() == 'graph'){
        return this;
    }else if(false !== this.el){
        var tagName     = this.el.prop('tagName').toLowerCase(),
            isFormTag   = this.formTags.indexOf(tagName) > -1,
            originalVal = (this.formula) ? this.computedValue : this.value,
            formattedVal= (
                            this.format != ''
                            && typeof(numeral) != 'undefined'
                            && originalVal !== ''
                            && originalVal !== false
                            && originalVal !== null
                            && data.ERROR.indexOf(originalVal) == -1
                            && $.isNumeric(originalVal)
                        )
                        ? numeral(originalVal).format(this.format)
                        : originalVal;

        //console.log('render computed value of '+this.address+ ' with formula '+this.formula);
        if(isFormTag){
            if(this.isCheckbox){
                this.el.prop('checked', (originalVal == this.el.val()));
            }else if(tagName == 'select'){
                this.el.val(originalVal);
            }else if(tagName == 'input' || tagName == 'textarea'){
                this.el.val(formattedVal);
            }
        }else{
            this.el.html(formattedVal);
        }
    }

    //console.log(typeof(this.conditionalStyle));

    if(typeof(this.conditionalStyle) == 'function'){
        var css = this.conditionalStyle.apply(null, [this.getValue(), this.el]);

        if(typeof(css) == 'object'){
            this.el.css(css);
        }
    }

    return this;
}

/**
 * resync cell value with element value, in case the form is reseted
 * @return {[type]} [description]
 */
cell.fx.resyncValue = function(){
    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : resyncing value with element value');

    if(false !== this.el){
        var tagName     = this.el.prop('tagName').toLowerCase(),
            isFormTag   = this.formTags.indexOf(tagName) > -1,
            elValue     = (isFormTag) ? this.el.val() : this.el.text();

        if(this.isCheckbox && !this.el.prop('checked')){
            elValue = this.el.attr('data-unchecked-value') || '';
        }

        this.setValue(elValue);
    }
};

/**
 * sync formula from the el to the cells object
 */
cell.fx.resyncFormula = function(){
    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : resyncing formula with the element formula');

    if(this.el && this.el.attr('data-formula') != this.formula){
        this.formula = this.el.attr('data-formula');
        this.buildDependency();
    }
}

/**
 * find the circular reference in cell dependency tree
 * @param  {string} address     the cell address that need to be checked
 * @return {bool}               true if circular reference found, false if not found
 */
cell.fx.checkCircularReference = function(address){
    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : checking circular reference');
    var a, isCircular = false;

    if(typeof(address) == 'undefined'){
        address = this.getAddress();
    }

    if(false !== this.formula){
        /** first, check if the dependencies is redudant */
        for(a in this.dependencies){
            isCircular = isCircular || (a == address);

            //console.log(prefix+'cell: '+this.getAddress()+', dependencies: '+a+', is circular: '+isCircular);
            if(isCircular){
                return true;
            }
        }

        /** second, check if the dependencies of the dependency is redudant */
        for(a in this.dependencies){
            //console.log(prefix+'cell: '+this.getAddress()+', dependencies of dependency: '+a+', is circular: '+isCircular);

            isCircular = isCircular || this.dependencies[a].checkCircularReference(address);
            if(isCircular){
                return true;
            }
        }
    }

    return isCircular;
};

/**
 * evaluate cell formula and put the result in computed value container
 * @return {mixed}
 */
cell.fx.evaluateFormula = function(){
    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : evaluating formula ['+this.formula+']');

    if(this.formula){
        try{
            this.sheet.setActiveCell(this);
            this.computedValue = this.sheet.evaluate(this.formula);
            //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : formula result: '+this.computedValue);
            return this.computedValue;
        }catch(e){
            //console.log(e);
            //this.computedValue = '#ERROR!'; //@@@@@MAD
            this.computedValue = '#n'; //@@@@@MAD
            console.error('formula error on '+this.address+' : '+this.formula, e);
            return false;
        }
    }

    return false;
};

/** form tag reference */
cell.fx.formTags = ['input', 'select', 'textarea', 'button'];

/**
 * set conditional style callback
 * @param {Function} callback [description]
 */
cell.fx.setConditionalStyle = function(callback){
    if(typeof(callback) == 'function'){
        this.conditionalStyle = callback;
    }
}

/**
 * set formatting rule to the cell
 * @param {string} format rule to define formatting on rendered value
 */
cell.fx.setFormat = function(format){
    this.format = format;
    if(false !== this.el){
        this.el.attr('data-format', format);
        this.renderComputedValue();
    }

    if(this.sheet.affectedCell.indexOf(this.address) == -1){
        this.sheet.affectedCell.push(this.address);
    }

    return this;
};

/**
 * return format definition of the current cell object
 * @return {string} format definition or false
 */
cell.fx.getFormat = function(){
    return this.format;
};

/**
 * set formula definition to the cell
 * @param {string} formula definition
 */
cell.fx.setFormula = function(formula){
    //console.log('set formula of #'+this.sheet.elementId+'!'+this.address+' to be '+formula);
    if(typeof(formula) !== 'string'){
        return false;
    }

    this.formula = formula;
    if(false !== this.el){
        this.el.attr('data-formula', formula);
    }

    //console.log('building dependency');
    this.buildDependency();

    //console.log('processing dependant');
    //this.processDependant(true, true);

    //this.evaluateFormula();
    //
    //
    if(this.sheet.affectedCell.indexOf(this.address) == -1){
        this.sheet.affectedCell.push(this.address);
    }
    return this;
};

cell.fx.getFormula = function(){
    return this.formula;
};

/**
 * get current cell address
 * @return {string}     cell address of the current cell object
 */
cell.fx.getAddress = function(){
    return this.address;
};

/**
 * get formatted value of the cell based on the formula definition
 * @return {string}     the formatted value
 */
cell.fx.getFormattedValue = function(){
    var originalVal = (this.formula) ? this.computedValue : this.value,
        formattedVal= (
            this.format != ''
            && typeof(numeral) != 'undefined'
            && originalVal !== ''
            && originalVal !== false
            && originalVal !== null
            && data.ERROR.indexOf(originalVal) == -1
            && $.isNumeric(originalVal)
        )
        ? numeral(originalVal).format(this.format)
        : originalVal;

    return formattedVal;
};

/**
 * set cell value and sync it with the bound element, and trigger recalculation on all cell depend to it
 * @param {mixed}   value to be inserted into the cell
 */
cell.fx.setValue = function(value){

    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : setting value to be : '+value);

    this.value = value;

    if(this.sheet.affectedCell.indexOf(this.address) == -1){
        this.sheet.affectedCell.push(this.address);
    }

    /* set value mean set value, no other thing should be done */
    return this;
};

cell.fx.getValue = function(){
    var returnValue;

    if(this.formula){
        returnValue = this.computedValue;
    }else{
        returnValue = this.value;
    }

    return returnValue;
}

/**
 * mark cell as affected by other cell, used to decide whether to
 * process the cell or not when processing dependency tree
 */
cell.fx.setAffected = function(affected){
    affected = typeof(affected) == 'undefined' ? true : affected;
    this.affected = affected;

    return this;
};

cell.fx.isAffected = function(){
    return this.affected;
};

/**
 * [setProcessed description]
 * @param {[type]} processed [description]
 */
cell.fx.setProcessed = function(processed){
    this.processed = (typeof(processed) == 'undefined') ? true : processed;

    //console.log('cell[#'+this.sheet.elementId+'!'+this.address+'] : mark as processed ['+processed+']');
    return this;
}

/**
 * [isProcessed description]
 * @return {Boolean} [description]
 */
cell.fx.isProcessed = function(){
    return this.processed;
};

cell.fx.highlightDependant = function(){
    for(var a in this.dependant){
        this.dependant[a].el.css('border', 'solid 1px blue');
    }
};

cell.fx.highlightDependency = function(){
    for(var a in this.dependencies){
        this.dependencies[a].el.css('border', 'solid 1px red');
    }
};

/**
 * Sheet object, represent each element as single sheet
 * @param  {string}     identifier :unique key for accessing sheet object internally
 * @param  {domElement} element    :dom element as scope for sheet to work with
 * @param  {object}     config     : configuration object
 * @return {void}
 */
function sheet(identifier, element, config){
    /** @type {string} The sheet unique identifier */
    this.identifier   = identifier;

    /** @type {object} jQuery dom element */
    this.el           = $(element);

    /** @type {string} Default language setting */
    this.lang         = 'en';

    /** @type {object} Cells registry containing all available cell */
    this.cells        = {};

    /** @type {object} Variable registry, containing all defined variable */
    this.variables    = {};

    /** @type {object} Sheet configuration object */
    this.config       = $.extend({}, defaultConfig, config);

    /** @type {number} Cell counter, count total cell in the sheet */
    this.counter      = 1;

    /** @type {boolean} Indicate if the sheet has relation with other sheet */
    this.relatedSheet = false;

    /** @type {string} The id of the element where the sheet is initialized and bound */
    this.elementId    = this.el.attr('id');

    /** @type {object} Registry containing sheets that depend on this sheet */
    this.dependant    = {};

    /** @type {object} Registry containing sheets that this sheet depend on*/
    this.dependencies = {};

    /** @type {boolean} Indicate the current sheet calculation is done */
    this.calculated   = false;

    /** @type {boolean} Indicate the current sheet calculation is in progress */
    this.calculating  = false;

    /** @type {object} Current cell object being calculated */
    this.activeCell   = null;
	this.totalCell    = 0;
    this.affectedCell = [];

    this.init();
};

sheet.fx = sheet.prototype;
sheet.fx.init = function(){
    //console.log('sheet[#'+this.elementId+'] : Initializing the sheet');
    var cells = this.el.find('[data-cell],[data-formula],[data-format]'),
        sheet = this,
        $cell;

    this.totalCell = cells.length;
    this.parser = parserFactory(this);
    this.el.attr('data-calx-identifier', this.identifier);

    cells.each(function(){
        $cell = new cell(sheet, this);
        sheet.registerCell($cell);
    });


    for(var cellAddr in this.config.data){
        if(typeof(this.cells[cellAddr]) == 'undefined'){
            $cell = new cell(sheet, undefined, cellAddr);
            sheet.registerCell($cell);
        }
    }

    //sheet.buildCellDependency();
    sheet.attachEvent();
};

/**
 * check circular reference on each cell registered to this sheet
 * @return {bool} true if exist, false if clear
 */
sheet.fx.checkCircularReference = function(){
    //console.log('sheet[#'+this.elementId+'] : checking circular reference');
    var a, response = {
            isCircular : false,
            cell : null
        };

    for(a in this.cells){
        response.isCircular = this.cells[a].checkCircularReference();
        if(true === response.isCircular){
            response.cell = this.cells[a];
            return response;
        }
    }

    return response;
}

/**
 * mark all cell as not processed
 */
sheet.fx.clearProcessedFlag = function(){
    //console.log('sheet[#'+this.elementId+'] : clearing the processed flag');
    for(var a in this.cells){
        if(false !== this.cells[a].formula){
            this.cells[a].setProcessed(false);
            this.cells[a].setAffected(true);
        }else{
            this.cells[a].setProcessed(true);
            this.cells[a].setAffected(false);
        }
    }
};

/**
 * building inter-cell dependency
 * once the formula is evaluated,
 * make sure all cell involved is evaluated first
 * @return {[type]} [description]
 */
sheet.fx.buildCellDependency = function(){
    //console.log('sheet[#'+this.elementId+'] : building cells dependency');
    var cell;

    for(cell in this.cells){
        this.cells[cell].buildDependency();
    }
};

sheet.fx.renderComputedValue = function(){
    //console.log('sheet[#'+this.elementId+'] : rendering all computed value to the element');

    //console.log(this.el.attr('id'));
    //console.log(this.affectedCell);
    for(var a = 0; a < this.affectedCell.length; a++){
        this.cells[this.affectedCell[a]].renderComputedValue();
    }
    this.clearAffectedCell();
};

sheet.fx.clearAffectedCell = function(){
    this.affectedCell = [];
};

sheet.fx.hasRelatedSheet = function(){
    return this.relatedSheet;
};

sheet.fx.clearCalculatedFlag = function(){
    var a;

    for(a in this.dependant){
        this.dependant[a].setCalculated(false);
    }


    for(a in this.dependencies){
        this.dependencies[a].setCalculated(false);
    }
};

sheet.fx.isCalculated = function(){
    return this.calculated;
};

sheet.fx.setCalculated = function(calculated){
    calculated = (typeof(calculated) == 'undefined') ? true : calculated;
    this.calculated  = calculated;
};

sheet.fx.clearDependencies = function(){
};

sheet.fx.registerDependant = function(dep){
    this.relatedSheet = true;
    if(typeof(this.dependant[dep.identifier]) == 'undefined'){
        this.dependant[dep.identifier] = dep;
    }
};

sheet.fx.registerDependency = function(dep){
    this.relatedSheet = true;
    if(typeof(this.dependencies[dep.identifier]) == 'undefined'){
        this.dependencies[dep.identifier] = dep;
    }
};

sheet.fx.obj = {
    type : 'cell'
};

sheet.fx.comparator = {
    greater: function(a, b){
        return a > b;
    },

    greaterEqual: function(a, b){
        return a >= b;
    },

    less: function(a, b){
        return a < b;
    },

    lessEqual : function(a, b){
        return a <= b;
    },

    equal: function(a,b){
        return a == b;
    },

    notEqual: function(a,b){
        return a != b;
    }
};

sheet.fx.getVariable = function(varName){
    var varIndex = varName[0],
        varUpperCase = varIndex.toUpperCase();

    if(varUpperCase == 'TRUE'){
        return true;
    }

    if(varUpperCase == 'FALSE'){
        return false;
    }

    if(varUpperCase == 'NULL'){
        return null;
    }

    if(typeof(this.variables[varIndex]) == 'undefined'){
        if(typeof(data.VARIABLE[varIndex]) == 'undefined'){
            return '#UNDEFINED_VARIABLE!';
        }else if(typeof(data.VARIABLE[varIndex]) == 'function'){
            return data.VARIABLE[varIndex].call(this);
        }else{
            return data.VARIABLE[varIndex];
        }
    }else if(typeof(this.variables[varIndex]) == 'function'){
        return this.variables[varIndex].call(this);
    }else{
        return this.variables[varIndex];
    }
};

sheet.fx.time = function(time){
    var $time   = time.split(':'),
        $today  = new Date(),
        $hour   = typeof($time[0]) == 'undefined' ? 0 : $time[0],
        $minute = typeof($time[1]) == 'undefined' ? 0 : $time[1],
        $second = typeof($time[2]) == 'undefined' ? 0 : $time[2],
        $result = new Date($today.getFullYear(), $today.getMonth(), $today.getDate(), $hour, $minute, $second);

    return $result;
};

sheet.fx.callFunction = function(functionName, params){
	//console.log("<==== calling function " + functionName + " ====>"); //@@@@@MAD
	//console.log('=='+functionName+'==', params); //@@@@@MAD
	
    var category, func;

    func = functionName.toUpperCase();
    if(typeof(formula[func]) == 'function'){
        return formula[func].apply(this, params);
    }

    //@@@@@MAD ###############################################################
	//english to german names functions 
	//https://www.sheetzoom.com/excel-formula-translator/STDEVA-in-German-EN-DE
	//https://www.sheetzoom.com/excel-formula-translator/STABWA-in-English-DE-EN

	//german ALIAS names for Excel functions
	const FUNC_NAMES = {
		//date
		"DATE" : "DATE", 			"DATUM" : "DATE",
		"DAYNAME" : "DAYNAME", 		"TAGNAME" : "DAYNAME",
		"EDATE" : "EDATE", 			"EDATUM" : "EDATE",
		
		//math
		"SUM" : "SUM", 			"SUMME" : "SUM",
		"SUMIF" : "SUMIF", 		"SUMMEWENN" : "SUMIF",
		"SUMIFS" : "SUMIFS", 	"SUMMEWENNS" : "SUMIFS",
		
		//statistic
		"AVERAGE" : "AVERAGE", 			"MITTELWERT" : "AVERAGE",
		"AVERAGEIF" : "AVERAGEIF",		"MITTELWERTWENN" : "AVERAGEIF",
		//"AVERAGEIFS" : "AVERAGEIFS",	"MITTELWERTWENNS" : "AVERAGEIFS",
		"MAX" : "MAX",
		"MAXA" : "MAXA",
		"MIN" : "MIN",
		"MINA" : "MINA",
		"STDEVA" : "STDEVA", 		"STABWA" : "STDEVA",
		"STDEVP" : "STDEVP", 		"STABWN" : "STDEVP",
		"STDEVPN0" : "STDEVPN0", 	"STABWNK0" : "STDEVPN0",
		//"STDEVPA" : "STDEVPA", 	"STABWNA" : "STDEVPA",
		"STDEVS" : "STDEVS", 		"STABWS" : "STDEVS",
		
		//logical
		"AND" : "AND", 		"UND" : "AND",
		"IF" : "IF", 		"WENN" : "IF",
		"NOT" : "NOT", 		"NICHT" : "NOT",
		"OR" : "OR", 		"ODER" : "OR",
		"XOR" : "XOR",
		
		//text
		"CONCAT" : "CONCAT", 	"TEXTKETTE" : "CONCAT",
		"JOIN" : "JOIN",
		"LEFT" : "LEFT", 		"LINKS" : "LEFT",
		"LEN" : "LEN", 			"LNGE" : "LEN",
		"LOWER" : "LOWER", 		"KLEIN" : "LOWER",
		"MID" : "MID", 			"TEIL" : "MID",
		"RIGHT" : "RIGHT", 		"RECHTS" : "RIGHT",
		"UPPER" : "UPPER", 		"GROSS" : "UPPER"
	};
	//date -> DATE/DATUM, DAYNAME/TAGNAME, EDATE/EDATUM
	//math -> SUM/SUMME, SUMIF/SUMMEWENN, SUMIFS/SUMMEWENNS, 
	//statistic -> AVERAGE/MITTELWERT, AVERAGEIF/MITTELWERTWENN, MIN, MAX, STDEVA/STABWA, STDEVP/STABWN, STDEVPN0/STABWNN0, STDEVS/STABWS
	//logical -> AND/UND, IF/WENN, NOT/NICHT, OR/ODER, 
	//text -> CONCAT/TEXTKETTE, JOIN/JOIN, LEFT/LINKS, LEN/LNGE, LOWER/KLEIN, MID/TEIL, RIGHT/RECHTS, UPPER/GROSS
    //@@@@@MAD ###############################################################
	
	
    for(category in formula){
        if(typeof(formula[category][func]) == 'function' ){
            return formula[category][func].apply(this, params);
        //if(typeof(formula[category][FUNC_NAMES[func]]) == 'function' ){
        //    return formula[category][FUNC_NAMES[func]].apply(this, params);
        }
    }

    return '#NAME?'
};

sheet.fx.getRemoteCell = function(sheet, address){
    var identifier = $(sheet).attr('data-calx-identifier');

    if(!identifier || typeof(calx.sheetRegistry[identifier]) == 'undefined'){
        return false;
    }

    return calx.sheetRegistry[identifier].getCell(address);
};

sheet.fx.getRemoteCellRange = function(sheet, addressStart, addressStop){
    var identifier = $(sheet).attr('data-calx-identifier');

    if(!identifier || typeof(calx.sheetRegistry[identifier]) == 'undefined'){
        return false;
    }

    return calx.sheetRegistry[identifier].getCellRange(addressStart, addressStop);
};

sheet.fx.getRemoteCellValue = function(sheet, address){
    var identifier = $(sheet).attr('data-calx-identifier');

    if(!identifier || typeof(calx.sheetRegistry[identifier]) == 'undefined'){
        return false;
    }

    return calx.sheetRegistry[identifier].getCellValue(address);
};

sheet.fx.getRemoteCellRangeValue = function(sheet, addressStart, addressStop){
    var identifier = $(sheet).attr('data-calx-identifier');

    if(!identifier || typeof(calx.sheetRegistry[identifier]) == 'undefined'){
        return false;
    }

    return calx.sheetRegistry[identifier].getCellRangeValue(addressStart, addressStop);
};

sheet.fx.getCellRangeValue = function(addressStart, addressStop){
    addressStart = addressStart.toUpperCase();
    addressStop = addressStop.toUpperCase();

    var cellRangeAddress= utility.cellRange(addressStart, addressStop),
        cellRangeLength = cellRangeAddress.length,
        cellRangeValue  = {},
        i;

    for (i = 0; i < cellRangeLength; i++) {
        cellRangeValue[cellRangeAddress[i]] = this.getCellValue(cellRangeAddress[i]);
    }

    return cellRangeValue;
};

sheet.fx.getCellValue = function(address){
    var cell = address.toUpperCase();
    if(typeof(this.cells[cell]) == 'undefined'){
        return false;
    }
    return this.cells[cell].getValue();
};

/**
 * evaluate given formula
 * @param  {string} formula     the formula need to be evaluated
 * @return {mixed}              result returned by the formula
 */
sheet.fx.evaluate = function(formula){
    //console.log('sheet[#'+this.elementId+'] : evaluating formula => '+formula);

    return this.parser.parse(formula);
};

/**
 * update cell reference inside the sheet, detect removed and added cells
 */
sheet.fx.update = function(){
    //console.log('sheet[#'+this.elementId+'] : updating cells registry with current state of the element');

    var cells = this.el.find('[data-cell],[data-formula],[data-format]'),
        sheet = this,
        $cell;

    this.totalCell = cells.length;

    /** detect and remove detached cells and its reference */
    for(var a in this.cells){
        if(this.cells[a].el && !$.contains(document, this.cells[a].el[0])){
            delete(this.cells[a]);
        }
    }

    /** add new cell reference */
    cells.each(function(){
        var cellAddr = $(this).attr('data-cell');

        if(cellAddr && typeof(sheet.cells[cellAddr]) == 'undefined'){
            //console.log('new cell found '+cellAddr);
            $cell = new cell(sheet, this);
            sheet.registerCell($cell);
        }else{
            //console.log('resync cell '+cellAddr);
            sheet.cells[cellAddr].resyncValue();
            sheet.cells[cellAddr].resyncFormula();
        }
    });

    /** rebuild the dependency tree */
    this.buildCellDependency();
};

/**
 * calculate all the sheet!
 */
sheet.fx.calculate = function(){
    //console.log('sheet[#'+this.elementId+'] : calculating the sheet');

    this.clearAffectedCell();

    if(typeof(this.config.onBeforeCalculate) == 'function'){
        this.config.onBeforeCalculate.call(this);
    }

    var a;

    this.calculateDependency(this.identifier);
    /** set all cell with formula as affected */
    this.clearProcessedFlag();

    for(a in this.cells){
        this.cells[a].processDependency();
    }

    this.setCalculated();
    //console.log(this.isCalculated());

    /*
    for(a in this.dependant){
        if(!this.dependant[a].isCalculated()){
            this.dependant[a].calculate();
        }
    }
    */

    for(a in this.cells){
        //console.log('recalculating cell');
        if(this.cells[a].hasRemoteDependency()){
            this.cells[a].evaluateFormula();
            //console.log('recalculating cell #'+this.el.attr('id')+'!'+a+'='+this.cells[a].getValue());
        }
    }

    this.calculateDependant(this.identifier);


    if(typeof(this.config.onAfterCalculate) == 'function'){
        this.config.onAfterCalculate.call(this);
    }

    if(typeof(this.config.onBeforeRender) == 'function'){
        this.config.onBeforeRender.call(this);
    }

    this.renderComputedValue();

    if(typeof(this.config.onAfterRender) == 'function'){
        this.config.onAfterRender.call(this);
    }

    return this;
};

sheet.fx.calculateDependant = function(skip){
};

sheet.fx.calculateDependency = function(skip){
};

/**
 * register singgle cell to sheet's cell registry
 * @param  {object} cell    cell object
 * @return {void}
 */
sheet.fx.registerCell = function(cell){
    var address = cell.getAddress()
    this.cells[address] = cell;

    if(typeof this.config.data[address] != 'undefined'){
        var cellConfig = this.config.data[address];

        if(typeof cellConfig.value != 'undefined'){
            cell.setValue(cellConfig.value);
            cell.renderComputedValue();
        }

        if(typeof cellConfig.format != 'undefined'){
            cell.setFormat(cellConfig.format);
        }

        if(typeof cellConfig.formula != 'undefined'){
            cell.setFormula(cellConfig.formula);
        }

        if(typeof cellConfig.conditional_style != 'undefined'){
            cell.setConditionalStyle(cellConfig.conditional_style);
        }
    }

    if(this.affectedCell.indexOf(cell.getAddress()) == -1){
        this.affectedCell.push(cell.getAddress());
    }
};

/**
 * register custom variable to the calx object
 * @param  {string} varName     variable name
 * @return {mixed}  varValue    variable value
 */
sheet.fx.registerVariable = function (varName, varValue) {
    if(typeof(varName) == 'object'){
        for(var a in varName){
            this.variables[a] = varName[a];
        }
    }else{
        this.variables[varName] = varValue;
    }
};

/**
 * get cell object based on given address
 * @param  {string} address     cell address (A1, B1 etc)
 * @return {cell|false}         cell object represented by the address or false if not found
 */
sheet.fx.getCell = function(address){

    address = address.toUpperCase();
    if(typeof(this.cells[address]) != 'undefined'){
        return this.cells[address];
    }else{
        return false;
    }
};

/**
 * get list of cell object based on given range
 * @param  {string} addressStart range start
 * @param  {string} addressStop  range stop
 * @return {object}              object containing all cell object in given range
 */
sheet.fx.getCellRange = function(addressStart, addressStop){

    addressStart = addressStart.toUpperCase();
    addressStop = addressStop.toUpperCase();

    var cellList        = utility.cellRange(addressStart, addressStop),
        cellListLength  = cellList.length,
        cellRange       = {},
        a;

    for(a = 0; a < cellListLength; a++){
        cellRange[cellList[a]] = this.getCell(cellList[a]);
    }

    return cellRange;
};

/**
 * Apply calculated and formatted value to elements that represent the cell
 * @return sheet object
 */
sheet.fx.applyChange = function(){
    //console.log('sheet[#'+this.elementId+'] : applying all computed value to the element');
    var a;
    for(a in this.cells){
        this.cells[a].processDependency(false, false);
    }

    for(a in this.cells){
        this.cells[a].renderComputedValue();
    }

    return this;
};sheet.fx.scan = function(){

};

/**
 * refresh is similar to update, but instead of scanning for added/removed cells,
 * it's remove whole cell registry and rebuild it
 */
sheet.fx.refresh = function(){
    //console.log('sheet[#'+this.elementId+'] : refreshing the sheet cells registry');
    var cells = this.el.find('[data-cell],[data-formula],[data-format]'),
        sheet = this,
        $cell;

    this.totalCell = cells.length;
    this.cells = {};

    cells.each(function(){
        $cell = new cell(sheet, this);
        sheet.registerCell($cell);
    });

    /** rebuild the dependency tree */
    this.buildCellDependency();
};

/**
 * reset the form to  it's original value, and resync the value with the cell registry
 */
sheet.fx.reset = function(){
    //console.log('sheet[#'+this.elementId+'] : resetting form elements');

    var forms;

    if(this.el.prop('tagName').toLowerCase() == 'form'){
        forms = this.el;
    }else{
        forms = this.el.find('form');
    }

    forms.each(function(){
        this.reset();
    });

    for(var a in this.cells){
        this.cells[a].resyncValue();
    }

    this.calculate();
};

/**
 * tell the sheet which cell is currently evaluating formula
 * @param {object} cell cell object
 */
sheet.fx.setActiveCell = function(cell){
    this.activeCell = cell;
};

/**
 * get the current active cell
 * @return {object} currently active cell object
 */
sheet.fx.getActiveCell = function(){
    return this.activeCell;
};

sheet.fx.attachEvent = function(){
    //console.log('sheet[#'+this.elementId+'] : attaching events to the element');

    var currentSheet = this;
//@@@@@MAD ###############################################################
/* 
    /**
     * get the unformatted value of the cell, and display it to the element
     * /
    this.el.on('calx.getValue', 'input[data-cell]', function(){
        var cellAddr    = $(this).attr('data-cell'),
            currentCell = currentSheet.cells[cellAddr],
            cellValue   = currentCell.getValue(),
            cellFormat  = currentCell.getFormat();

        if(cellFormat && cellFormat.indexOf('%') >= 0){
            cellValue = cellValue*100+' %';
        }

        if(!currentCell.isCheckbox){
            currentCell.el.val(cellValue);
        }
        //console.log(currentCell.getValue());
    });

    /**
     * get the formatted value of the cell, and display it to the element
     * /
    this.el.on('calx.renderComputedValue', 'input[data-cell]', function(){
        var cellAddr    = $(this).attr('data-cell'),
            currentCell = currentSheet.cells[cellAddr];

        currentCell.renderComputedValue();
    });

    /**
     * update value of the current cell internally
     * /
    this.el.on('calx.setValue', 'input[data-cell], select[data-cell]', function(){
        var element     = $(this),
            cellAddr    = element.attr('data-cell'),
            currentCell = currentSheet.cells[cellAddr],
            oldVal      = currentCell.getValue(),
            newVal      = currentCell.el.val(),
            cellFormat  = currentCell.getFormat();

        if(currentCell.isCheckbox && currentCell.el.attr('type') == 'checkbox'){
            if(currentCell.el.prop('checked')){
                currentCell.setValue(newVal);
            }else{
                var uncheckedVal = currentCell.el.attr('data-unchecked');
                    uncheckedVal = (typeof(uncheckedVal) == 'undefined') ? '' : uncheckedVal,
                    newVal       = uncheckedVal;

                currentCell.setValue(uncheckedVal);
            }
        }else if(currentCell.isCheckbox && currentCell.el.attr('type') == 'radio'){
            currentCell.setValue(newVal);

            currentSheet.el
                        .find('[name='+currentCell.el.attr('name')+']')
                        .not(currentCell.el)
                        .each(function(){
                            var radioBox     = $(this),
                                uncheckedVal = radioBox.attr('data-unchecked'),
                                cellAddr     = radioBox.attr('data-cell');

                            uncheckedVal = (typeof(uncheckedVal) == 'undefined') ? '' : uncheckedVal;

                            currentSheet.cells[cellAddr].setValue(uncheckedVal);
                        });
        }else{
            if(cellFormat && typeof(numeral) != 'undefined' && $.trim(newVal) !== ''){
                rawValue = numeral().unformat(newVal);

                if(cellFormat.indexOf('%') > -1 && (newVal).indexOf('%') == -1){
                    rawValue = rawValue/100;

                }
            }else{
                rawValue = ($.isNumeric(newVal)) ? parseFloat(newVal) : newVal;
            }

            currentCell.setValue(rawValue);
        }

        if(oldVal != newVal){
            currentCell.setAffected(true);
        }

    });

    /**
     * calculate the whole sheet
     * /
    this.el.on('calx.calculateSheet', 'input[data-cell]', function(){
        currentSheet.calculate();
    });

    /**
     * update current cell value, and recalculate it's dependant
     * /
    this.el.on('calx.calculateCellDependant', 'input[data-cell], select[data-cell]', function(){
        var cellAddr    = $(this).attr('data-cell'),
            currentCell = currentSheet.cells[cellAddr];

        if(!currentCell.isAffected()){
            return;
        }

        if(true === calx.isCalculating){
            calx.isCalculating = false;
        }
        currentSheet.clearProcessedFlag();
        currentCell.calculate(true, false);

        if(currentSheet.hasRelatedSheet()){
            currentSheet.calculate();
        }else{
            currentSheet.renderComputedValue();
        }

    });

    /**
     * bind to internal event, so no need to unbind the real event on destroy
     * /
    this.el.on(currentSheet.config.autoCalculateTrigger, 'input[data-cell]',function(){
        //console.log('blurred');
        var $this = $(this);
        if(!$this.attr('data-formula')){
            if(currentSheet.config.autoCalculate){
                //console.log('calculating dependant');
                setTimeout(function(){
                    $this.trigger('calx.calculateCellDependant');
                }, 50);
            }
        }
    });

    this.el.on('blur', 'input[data-cell]', function(){
        //console.log($(this).attr('data-cell')+'blur');
        $(this).trigger('calx.renderComputedValue');
    });

    /**
     * change behaviour, based on configuration
     * autoCalculate : on   => calx.calculateCellDependant
     * autoCalculate : off  => calx.setValue
     * /
    this.el.on('change', 'select[data-cell]', function(){
        $(this).trigger('calx.setValue');

        if(currentSheet.config.autoCalculate){
            $(this).trigger('calx.calculateCellDependant');
        }
    });

    this.el.on('click', 'input[data-cell][type=checkbox], input[data-cell][type=radio]', function(){

        $(this).trigger('calx.setValue');

        if(currentSheet.config.autoCalculate){
            $(this).trigger('calx.calculateCellDependant');
        }
    });

    /** focus does not depend on configuration, always get the value on focus * /
    this.el.on('focus', 'input[data-cell]',function(){
        //console.log($(this).attr('data-cell')+'focus');
        $(this).trigger('calx.getValue');
    });

    /** keyup does not depend on configuration, always set value on keyup * /
    this.el.on('keyup', 'input[data-cell]',function(e){
        //console.log($(this).attr('data-cell')+'key up');
        if($(this).attr('data-formula')){
            e.preventDefault();
            return false;
        }else{
            $(this).trigger('calx.setValue');
        }
    });
*/
//@@@@@MAD ###############################################################
};

sheet.fx.detachEvent = function(){
    //console.log('sheet[#'+this.elementId+'] : detaching events from the element');

    this.el.off('calx.getValue');
    this.el.off('calx.setValue');
    this.el.off('calx.renderComputedValue');
    this.el.off('calx.calculateSheet');
    this.el.off('calx.calculateCellDependant');
}


/**
 * [calx : the calx core object to work with jquery as plugin]
 * @type {Object}
 */
var calx = {
	/** flag to indicate that calx is calculating */
	isCalculating : false,

	/** Calx version */
	version : '2.2.7',

	/** sheets collection */
	sheetRegistry : {},

    /**
	 * initialize sheet object and register to internal calx.sheetRegistry
	 *
	 * @param  {object} option      option to override the default option
	 * @return {object}             jQuery object
	 */
	init : function (option) {
		var a, sheetIdentifier;

		/** initializing sheet object on each elements */
		this.each(function(){
			//console.log('initialize sheet');
			sheetIdentifier = $(this).attr('data-calx-identifier');

			if(!sheetIdentifier || typeof(calx.sheetRegistry[sheetIdentifier]) == 'undefined'){
				sheetIdentifier = 'CALX'+Object.keys(calx.sheetRegistry).length;

				calx.sheetRegistry[sheetIdentifier] = new sheet(sheetIdentifier, this, option);

			}else{
				//console.log('second call should be refresh');
				calx.sheetRegistry[sheetIdentifier].refresh();
			}
		});

		/** building dependency tree between cell and sheet */
		for(sheetIdentifier in calx.sheetRegistry){
			//console.log('build cell dependency');
			calx.sheetRegistry[sheetIdentifier].buildCellDependency();
		}

		/** apply additional action based on configuration */
		for(sheetIdentifier in calx.sheetRegistry){

			/** check circular reference after tree has been built */
			if(calx.sheetRegistry[sheetIdentifier].config.checkCircularReference){
				var reference = calx.sheetRegistry[sheetIdentifier].checkCircularReference();

				if(reference.isCircular){
					var errorMessage = 'Circular reference detected, this may cause calx to stop working.\ncell : '
										+reference.cell.getAddress()
										+'\nformula : '
										+reference.cell.getFormula()
										+'\n\nPlease check each cells involved in the formula that has direct or indirect reference to '
										+reference.cell.getAddress();

					alert(errorMessage);
					$.error(errorMessage);
				}
			}

			/** calculate and render the result */
			if(calx.sheetRegistry[sheetIdentifier].config.autoCalculate){
				calx.sheetRegistry[sheetIdentifier].calculate();
			}

			calx.sheetRegistry[sheetIdentifier].renderComputedValue();
		}

		return this;
	},
	/**
	 * register custom function to the calx formula sets
	 * @param  {string}     funcName        the function name, must be all uppercase
	 * @param  {function}   funcDefinition  the function definition to describe how the function should behave
	 * @param  {bool}       override        override flag, should it override built in function if the same name exists
	 * @return {void}
	 */
	registerFunction : function (funcName, funcDefinition, override) {
		override = (typeof(override) == 'undefined') ? false : override;

		if(override){
			for(var a in formula){
				if(typeof(formula[a][funcName]) != 'undefined'){
					delete(formula[a][funcName]);
				}
			}
		}
		formula.user_defined[funcName] = funcDefinition;
	},
	/**
	 * register custom variable to the calx object / sheet object
	 * @param  {string} varName     variable name
	 * @param  {mixed}  varValue    variable value
	 * @param  {bool}   global      register variable as global or only in current sheet
	 */
	registerVariable : function (varName, varValue, global) {
		global = typeof(global) == 'undefined' ? false : global;

		if(this.length === 0){
			global = true;
		}

		if(global){
			if(typeof(varName) == 'object'){
				for(var a in varName){
					data.VARIABLE[a] = varName[a];
				}
			}else{
				data.VARIABLE[varName] = varValue;
			}
		}else{
			this.each(function(){
				var sheetIdentifier = $(this).attr('data-calx-identifier');

				if(sheetIdentifier && typeof(calx.sheetRegistry[sheetIdentifier]) != 'undefined'){
					calx.sheetRegistry[sheetIdentifier].registerVariable(varName, varValue);
					calx.sheetRegistry[sheetIdentifier].calculate();
				}
			});
		}

		return this;
	},
	/**
	 * refresh sheet reference to the current dom state and rebuild
	 * the cell registry and dependency tree from the scratch
	 *
	 * @return {object}             jQuery object
	 */
	refresh : function () {
		return this.each(function(){
			var sheetIdentifier = $(this).attr('data-calx-identifier');
			//console.log(sheetIdentifier);

			if(sheetIdentifier && typeof(calx.sheetRegistry[sheetIdentifier]) != 'undefined'){
				calx.sheetRegistry[sheetIdentifier].refresh();
			}
		});
	},
	/**
	 * update sheet reference to the current dom state
	 */
	update : function () {
		return this.each(function(){
			var sheetIdentifier = $(this).attr('data-calx-identifier');
			//console.log(sheetIdentifier);

			if(sheetIdentifier && typeof(calx.sheetRegistry[sheetIdentifier]) != 'undefined'){
				calx.sheetRegistry[sheetIdentifier].update();
			}
		});
	},
	/**
	 * get sheet object bound to the element
	 * @return {object}             the sheet object
	 */
	getSheet : function(){
		var $this       = $(this),
			$identifier = $this.attr('data-calx-identifier');

		return typeof(calx.sheetRegistry[$identifier]) == 'undefined' ? false : calx.sheetRegistry[$identifier];
	},
	/**
	 * get cell object of current sheet related to the selected element,
	 * the selector should only select single object, e.g. $('#id')
	 *
	 * @param  {string} address     the cell's address
	 * @return {object}             the cell's object
	 */
	getCell : function(address){
		var $this       = $(this),
			$identifier = $this.attr('data-calx-identifier'),
			$sheet      = calx.sheetRegistry[$identifier];

		return $sheet.getCell(address);
	},
	/**
	 * Get the utility object in case its needed
	 * @return {object}     utility object
	 */
	getUtility : function(){
		return utility;
	},
	/**
	 * Get the full forula set object in case its needed
	 * @return {object}     formula object
	 */
	getFormula : function(){
		return formula;
	},
	/**
	 * Evaluate formula specific to the selected sheet,
	 * the selector should only select single object, e.g. $('#id')
	 *
	 * @param  {string} formula     the formula to be evaluated
	 * @return {mixed}              result of the formula evaluation
	 */
	evaluate : function(formula){
		var $this       = $(this),
			$identifier = $this.attr('data-calx-identifier'),
			$sheet      = calx.sheetRegistry[$identifier];

		return $sheet.evaluate(formula);
	},
	/**
	 * Destroy calx instance and remove reference from the element
	 *
	 * @return {object}     jQuery Object
	 */
	destroy : function(){
		this.each(function(){
			var $sheet          = $(this),
				a,
				sheetIdentifier = $sheet.attr('data-calx-identifier');

			$sheet.removeAttr('data-calx-identifier');

			if(typeof(calx.sheetRegistry[sheetIdentifier]) != 'undefined'){
				calx.sheetRegistry[sheetIdentifier].detachEvent();
				calx.sheetRegistry[sheetIdentifier].clearDependencies();
				delete calx.sheetRegistry[sheetIdentifier];
			}
		});

		return this;
	},
	/**
	 * Reset the form to the initial value and re-sync the value with the sheet object
	 */

    reset: function(){
		return this.each(function(){
			var sheetIdentifier = $(this).attr('data-calx-identifier');
			//console.log(sheetIdentifier);

			if(sheetIdentifier && typeof(calx.sheetRegistry[sheetIdentifier]) != 'undefined'){
				calx.sheetRegistry[sheetIdentifier].reset();
			}
		});
	},
	/**
	 * calculate sheet object related to the selected element
	 *
	 * @return {object} jQuery Object
	 */
	calculate : function(){

		return this.each(function(){
			/** get the sheet identifier attached to the element */
			var sheetIdentifier = $(this).attr('data-calx-identifier');
			//console.log(sheetIdentifier);

			/** retrieve te sheet objectfrom registry, and calculate */
			if(sheetIdentifier && typeof(calx.sheetRegistry[sheetIdentifier]) != 'undefined'){
				calx.sheetRegistry[sheetIdentifier].calculate();
			}
		});
	},
	/**
	 * set value of specific cell on the sheet related to the selected element,
	 * the selector should only select single object, e.g. $('#id')
	 *
	 * @param  {string} address     the cell's address
	 * @param  {string} value       the cell's value
	 * @return {void}
	 */
	setValue : function(address, value){
		var $this       = $(this),
			$identifier = $this.attr('data-calx-identifier'),
			$sheet      = calx.sheetRegistry[$identifier],
			$cell       = $sheet.getCell(address);

		$cell.setValue(value).renderComputedValue();

		if($sheet.config.autoCalculate){
			$sheet.calculate();
		}
    },
    //@@@@@MAD
	/**
	 * return sheetRegistry 
	 */
	getSheetRegistry : function(){
		return calx.sheetRegistry;
	} //@@@@@MAD
};
	
	/**
     * the surrogate of the calx world to the jQuery world
     * @param  string $action  [calx method]
     * @param  object $options [option object]
     * @return jQuery
     */
    $.fn.calx = function($action, $options) {
		//console.log('calx***********',$action, $options); //@@@@@MAD
        if (calx[$action]) {
            return calx[$action].apply(this, Array.prototype.slice.call(arguments, 1));
        } else if (typeof($action) == 'object' || typeof($action) == 'undefined') {
            var $calx = calx.init.apply(this, arguments);
            return $calx;
        } else {
            $.error('Method ' + $action + ' does not exist on jQuery.calx');
        }
    };
})(jQuery, numeral, moment, jStat);
